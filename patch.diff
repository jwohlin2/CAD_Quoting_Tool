 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/appV5.py b/appV5.py
index 925021023dfb608186504c4a2c5c497a9517d277..e12cade0c9bf981764e6cd3c9e586ea94690ee29 100644
--- a/appV5.py
+++ b/appV5.py
@@ -43,50 +43,61 @@ from pathlib import Path
 from types import SimpleNamespace
 
 from cad_quoter.app import runtime as _runtime
 from cad_quoter.app._value_utils import (
     _coerce_user_value,
     _format_entry_value,
     _format_value,
 )
 from cad_quoter.app.container import (
     ServiceContainer,
     SupportsPricingEngine,
     create_default_container,
 )
 from cad_quoter.config import (
     AppEnvironment,
     ConfigError,
     configure_logging,
     logger,
 )
 from cad_quoter.config import (
     describe_runtime_environment as _describe_runtime_environment,
 )
 from cad_quoter.utils.geo_ctx import _should_include_outsourced_pass
 from cad_quoter.utils import sheet_helpers
 from cad_quoter.utils.scrap import _estimate_scrap_from_stock_plan
+from cad_quoter.utils.render_utils import (
+    fmt_hours,
+    fmt_money,
+    fmt_percent,
+    fmt_range,
+    format_currency,
+    format_dimension,
+    format_hours,
+    format_hours_with_rate,
+    format_percent,
+)
 from cad_quoter.estimators import SpeedsFeedsUnavailableError
 _DRILLING_DATA_PATH = Path(__file__).resolve().parent / "data" / "drilling.json"
 _DRILLING_COEFFICIENTS: dict[str, Any] | None = None
 
 
 def _load_drilling_coefficients() -> dict[str, Any]:
     """Return cached drilling estimator coefficients from ``data/drilling.json``."""
 
     global _DRILLING_COEFFICIENTS
     if _DRILLING_COEFFICIENTS is None:
         try:
             with _DRILLING_DATA_PATH.open("r", encoding="utf-8") as handle:
                 _DRILLING_COEFFICIENTS = json.load(handle)
         except FileNotFoundError:
             _DRILLING_COEFFICIENTS = {}
     return _DRILLING_COEFFICIENTS
 
 
 from cad_quoter.llm_overrides import (
     HARDWARE_PASS_LABEL,
     LEGACY_HARDWARE_PASS_LABEL,
     _as_float_or_none,
     _canonical_pass_label,
     _plate_mass_properties,
     _plate_mass_from_dims,
@@ -6089,55 +6100,53 @@ def _format_planner_bucket_line(
             hr_val = 0.0
     if hr_val <= 0 and minutes_val > 0:
         hr_val = minutes_val / 60.0
 
     total_cost = amount
     for key_option in ("total_cost", "total$", "total"):
         if key_option in info:
             try:
                 candidate = float(info.get(key_option) or 0.0)
             except Exception:
                 continue
             if candidate:
                 total_cost = candidate
                 break
 
     rate_val = 0.0
     if isinstance(meta, _MappingABC):
         try:
             rate_val = float(meta.get("rate", 0.0) or 0.0)
         except Exception:
             rate_val = 0.0
     if rate_val <= 0 and hr_val > 0 and total_cost > 0:
         rate_val = total_cost / hr_val
 
     if currency_formatter is None:
-        currency_formatter = lambda x: f"${float(x):,.2f}"  # pragma: no cover
+        currency_formatter = lambda x: fmt_money(x, "$")  # pragma: no cover
 
-    hours_text = f"{max(hr_val, 0.0):.2f} hr"
-    if hr_val <= 0:
-        hours_text = "0.00 hr"
+    hours_text = fmt_hours(hr_val)
     if rate_val > 0:
         rate_text = f"{currency_formatter(rate_val)}/hr"
     else:
         rate_text = "—"
 
     display_override = (
         f"{_display_bucket_label(canon_key, label_overrides)}: {hours_text} × {rate_text} →"
     )
     return (display_override, float(total_cost), hr_val, rate_val)
 
 
 def _extract_bucket_map(source: Mapping[str, Any] | None) -> dict[str, dict[str, Any]]:
     bucket_map: dict[str, dict[str, Any]] = {}
     if not isinstance(source, _MappingABC):
         return bucket_map
     struct: Mapping[str, Any] = source
     buckets_obj = source.get("buckets") if isinstance(source, _MappingABC) else None
     if isinstance(buckets_obj, _MappingABC):
         struct = buckets_obj
     for raw_key, raw_value in struct.items():
         canon = _canonical_bucket_key(raw_key)
         if not canon:
             continue
         if isinstance(raw_value, _MappingABC):
             bucket_map[canon] = {str(k): v for k, v in raw_value.items()}
@@ -7460,53 +7469,51 @@ def render_quote(  # type: ignore[reportGeneralTypeIssues]
         if isinstance(meta, _MappingABC):
             try:
                 hr_val = float(meta.get("hr", 0.0) or 0.0)
             except Exception:
                 hr_val = 0.0
         if hr_val <= 0 and minutes_val > 0:
             hr_val = minutes_val / 60.0
         total_cost = amount
         for key_option in ("total_cost", "total$", "total"):
             if key_option in info:
                 try:
                     candidate = float(info.get(key_option) or 0.0)
                 except Exception:
                     continue
                 if candidate:
                     total_cost = candidate
                     break
         rate_val = 0.0
         if isinstance(meta, _MappingABC):
             try:
                 rate_val = float(meta.get("rate", 0.0) or 0.0)
             except Exception:
                 rate_val = 0.0
         if rate_val <= 0 and hr_val > 0 and total_cost > 0:
             rate_val = total_cost / hr_val
-        hours_text = f"{max(hr_val, 0.0):.2f} hr"
-        if hr_val <= 0:
-            hours_text = "0.00 hr"
+        hours_text = fmt_hours(hr_val)
         if rate_val > 0:
             rate_text = f"{_m(rate_val)}/hr"
         else:
             rate_text = "—"
         display_override = (
             f"{_display_bucket_label(canon_key, label_overrides)}: {hours_text} × {rate_text} →"
         )
         return (display_override, float(total_cost), hr_val, rate_val)
 
     bucket_order = [
         "milling",
         "drilling",
         "counterbore",
         "countersink",
         "tapping",
         "grinding",
         "finishing_deburr",
         "saw_waterjet",
         "inspection",
         "assembly",
         "packaging",
         "misc",
     ]
     def _planner_bucket_info(bucket_key: str) -> Mapping[str, Any]:
         rollup_info = bucket_rollup_map.get(bucket_key)
@@ -7615,65 +7622,65 @@ def render_quote(  # type: ignore[reportGeneralTypeIssues]
                     material.get("material_name")
                     or material.get("material")
                     or g.get("material")
                     or ui_vars.get("Material")
                     or ""
                 )
             if isinstance(material_name_display, str):
                 material_name_display = material_name_display.strip()
             else:
                 material_name_display = str(material_name_display).strip()
             if material_name_display:
                 material_display_label = str(material_name_display)
                 material_selection.setdefault("material_display", material_display_label)
                 material_display_for_debug = material_name_display
                 append_line(f"  Material used:  {material_name_display}")
 
             if matcost or show_zeros:
                 total_material_cost = float(matcost or 0.0)
                 material_net_cost = total_material_cost
             scrap_credit_lines: list[str] = []
             if scrap_credit_entered and scrap_credit:
                 credit_display = _m(scrap_credit)
                 if credit_display.startswith(currency):
                     credit_display = f"-{credit_display}"
                 else:
-                    credit_display = f"-{currency}{float(scrap_credit):,.2f}"
+                    credit_display = f"-{fmt_money(scrap_credit, currency)}"
                 scrap_credit_lines.append(f"  Scrap Credit: {credit_display}")
                 scrap_credit_mass_lb = _coerce_float_or_none(
                     material.get("scrap_credit_mass_lb")
                 )
                 scrap_credit_unit_price_lb = _coerce_float_or_none(
                     material.get("scrap_credit_unit_price_usd_per_lb")
                 )
                 if scrap_credit_mass_lb and scrap_credit_unit_price_lb:
                     scrap_credit_mass_g = (
                         float(scrap_credit_mass_lb) / LB_PER_KG * 1000.0
                     )
                     scrap_credit_lines.append(
                         "    based on "
-                        f"{_format_weight_lb_oz(scrap_credit_mass_g)} × {currency}{float(scrap_credit_unit_price_lb):,.2f} / lb"
+                        f"{_format_weight_lb_oz(scrap_credit_mass_g)} × {fmt_money(scrap_credit_unit_price_lb, currency)} / lb"
                     )
             net_mass_val = _coerce_float_or_none(net_mass_g)
             effective_mass_val = _coerce_float_or_none(mass_g)
             removal_mass_val = None
             for removal_key in ("material_removed_mass_g", "material_removed_mass_g_est"):
                 removal_mass_val = _coerce_float_or_none(material.get(removal_key))
                 if removal_mass_val:
                     break
             scrap_fraction_val = normalize_scrap_pct(scrap)
             if scrap_fraction_val <= 0:
                 scrap_fraction_val = None
             base_mass_for_scrap = None
             if net_mass_val and net_mass_val > 0:
                 base_mass_for_scrap = float(net_mass_val)
             elif effective_mass_val and effective_mass_val > 0:
                 base_mass_for_scrap = float(effective_mass_val)
             scrap_adjusted_mass_val: float | None = None
             if base_mass_for_scrap:
                 if removal_mass_val and removal_mass_val > 0:
                     scrap_adjusted_mass_val = max(0.0, base_mass_for_scrap - float(removal_mass_val))
                 elif scrap_fraction_val is not None:
                     scrap_adjusted_mass_val = max(0.0, base_mass_for_scrap * (1.0 - scrap_fraction_val))
                 elif (
                     effective_mass_val is not None
                     and net_mass_val is not None
@@ -8258,51 +8265,51 @@ def render_quote(  # type: ignore[reportGeneralTypeIssues]
                     or nre.get("fixture_per_part")
                     or 0.0
                 )
             except Exception:
                 fix_pp = 0.0
         if fix_pp > 0:
             label = "Fixture Build (amortized)"
             existing_fix = process_costs_canon.get("fixture_build_amortized")
             if existing_fix is not None and abs(float(existing_fix or 0.0) - fix_pp) <= 0.01:
                 amortized_nre_total += fix_pp
                 labor_costs_display[label] = float(labor_costs_display.get(label, 0.0)) + fix_pp
                 display_labor_for_ladder += fix_pp
             else:
                 detail_args: list[str] = []
                 fixture_detail = nre_detail.get("fixture", {}) if isinstance(nre_detail, dict) else {}
                 fixture_build_hr_detail = float(fixture_detail.get("build_hr", 0.0) or 0.0)
                 fixture_rate_detail = float(
                     fixture_detail.get("build_rate", rates.get("FixtureBuildRate", 0.0))
                 )
                 if fixture_build_hr_detail > 0:
                     detail_args.append(
                         f"- Build labor (lot): {_hours_with_rate_text(fixture_build_hr_detail, fixture_rate_detail)}"
                     )
                 soft_jaw_hr = float(fixture_detail.get("soft_jaw_hr", 0.0) or 0.0)
                 if soft_jaw_hr > 0:
-                    detail_args.append(f"Soft jaw prep {soft_jaw_hr:.2f} hr")
+                    detail_args.append(f"Soft jaw prep {fmt_hours(soft_jaw_hr)}")
                 if qty > 1:
                     detail_args.append(f"Amortized across {qty} pcs")
                 if detail_args:
                     detail_lookup["Fixture Build (amortized)"] = "; ".join(detail_args)
                 _add_labor_cost_line(
                     label,
                     fix_pp,
                     detail_bits=detail_args or None,
                 )
                 amortized_nre_total += fix_pp
                 labor_costs_display[label] = float(labor_costs_display.get(label, 0.0)) + fix_pp
                 display_labor_for_ladder += fix_pp
                 process_costs_canon.pop("fixture_build_amortized", None)
             amortized_labels_added.add(label)
 
     process_items = list((process_costs or {}).items())
     ordered_process_items: list[tuple[str, Any]] = []
     remaining_process_items: list[tuple[str, Any]] = []
     seen_process_keys: set[str] = set()
 
     for bucket in PREFERRED_PROCESS_BUCKET_ORDER:
         for key, value in process_items:
             if _normalize_bucket_key(key) != bucket:
                 continue
             try:
@@ -8411,51 +8418,51 @@ def render_quote(  # type: ignore[reportGeneralTypeIssues]
         except Exception:
             numeric_hours = 0.0
         if not canon_key:
             continue
         charged_hours_by_canon[canon_key] = (
             charged_hours_by_canon.get(canon_key, 0.0) + numeric_hours
         )
 
     def _record_hour_entry(label: str, value: float, *, include_in_total: bool = True) -> None:
         try:
             numeric_value = float(value or 0.0)
         except Exception:
             numeric_value = 0.0
 
         if not ((numeric_value > 0) or show_zeros):
             return
 
         single_piece_qty = False
         try:
             single_piece_qty = qty_for_hours > 0 and (qty_for_hours == 1 or math.isclose(qty_for_hours, 1.0))
         except Exception:
             single_piece_qty = False
 
         if single_piece_qty and numeric_value > 24.0:
             warning = (
-                f"{label} hours capped at 24 hr for single-piece quote (was {numeric_value:.2f} hr)."
+                f"{label} hours capped at {fmt_hours(24.0, decimals=0)} for single-piece quote (was {fmt_hours(numeric_value)})."
             )
             if warning not in red_flags:
                 red_flags.append(warning)
             numeric_value = 24.0
 
         hour_summary_entries[label] = (numeric_value, include_in_total)
 
     programming_meta = (nre_detail or {}).get("programming") or {}
     try:
         programming_hours = float(programming_meta.get("prog_hr", 0.0) or 0.0)
     except Exception:
         programming_hours = 0.0
 
     fixture_meta = (nre_detail or {}).get("fixture") or {}
     try:
         fixture_hours = float(fixture_meta.get("build_hr", 0.0) or 0.0)
     except Exception:
         fixture_hours = 0.0
 
     try:
         qty_for_hours = float(qty)
     except Exception:
         qty_for_hours = 0.0
     if qty_for_hours <= 0:
         qty_for_hours = 0.0
@@ -9030,54 +9037,54 @@ def render_quote(  # type: ignore[reportGeneralTypeIssues]
             lines,
             mat_canon=mat_canon, mat_group=mat_group, row_group=row_group,
             holes_deep=holes_deep, holes_std=holes_std,
             dia_vals_in=dia_vals, depth_vals_in=depth_vals,
             sfm_deep=sfm_deep, sfm_std=sfm_std,
             ipr_deep_vals=ipr_deep_vals, ipr_std_val=ipr_std_val,
             rpm_deep_vals=rpm_deep_vals, rpm_std_vals=rpm_std_vals,
             ipm_deep_vals=ipm_deep_vals, ipm_std_vals=ipm_std_vals,
             index_min_per_hole=index_min, peck_min_rng=peck_min_rng,
             toolchange_min_deep=tchg_deep, toolchange_min_std=tchg_std,
         )
 
         subtotal_min, seen_deep, seen_std = _render_time_per_hole(
             lines, bins=bins, index_min=index_min, peck_min_deep=peck_min_deep, peck_min_std=peck_min_std,
         )
 
         # Single toolchange per op (if present at least once)
         tool_add = (tchg_deep if seen_deep else 0.0) + (tchg_std if seen_std else 0.0)
         append_line(
             f"Toolchange adders: Deep-Drill {tchg_deep:.2f} min + Drill {tchg_std:.2f} min = {tool_add:.2f} min"
             if tool_add > 0
             else "Toolchange adders: -"
         )
         append_line("-" * 66)
         append_line(
-            f"Subtotal (per-hole × qty) ............... {subtotal_min:.2f} min  ({subtotal_min/60.0:.2f} hr)"
+            f"Subtotal (per-hole × qty) ............... {subtotal_min:.2f} min  ({fmt_hours(subtotal_min/60.0)})"
         )
         append_line(
-            f"TOTAL DRILLING (with toolchange) ........ {subtotal_min + tool_add:.2f} min  ({(subtotal_min + tool_add)/60.0:.2f} hr)"
+            f"TOTAL DRILLING (with toolchange) ........ {subtotal_min + tool_add:.2f} min  ({fmt_hours((subtotal_min + tool_add)/60.0)})"
         )
         append_line("")
     except Exception:
         # If anything goes sideways here, do not break the quote – just skip this block.
         pass
 
     append_line("")
 
     # ---- Pricing ladder ------------------------------------------------------
     append_line("Pricing Ladder")
     append_line(divider)
     overhead_pct    = float(applied_pcts.get("OverheadPct", 0.0) or 0.0)
     ga_pct          = float(applied_pcts.get("GA_Pct", 0.0) or 0.0)
     contingency_pct = float(applied_pcts.get("ContingencyPct", 0.0) or 0.0)
     expedite_pct    = float(applied_pcts.get("ExpeditePct", 0.0) or 0.0)
 
     with_overhead    = subtotal * (1.0 + overhead_pct)
     with_ga          = with_overhead * (1.0 + ga_pct)
     with_contingency = with_ga * (1.0 + contingency_pct)
     with_expedite    = with_contingency * (1.0 + expedite_pct)
 
     row("Subtotal (Labor + Directs):", subtotal)
     row(f"+ Overhead ({_pct(applied_pcts.get('OverheadPct'))}):",     with_overhead - subtotal)
     row(f"+ G&A ({_pct(applied_pcts.get('GA_Pct'))}):",               with_ga - with_overhead)
     row(f"+ Contingency ({_pct(applied_pcts.get('ContingencyPct'))}):", with_contingency - with_ga)
@@ -11940,51 +11947,55 @@ def _legacy_estimate_drilling_hours(
                     min_f = _coerce_float_or_none(min_val)
                     max_f = _coerce_float_or_none(max_val)
                     if min_f is None and max_f is None:
                         return "-"
                     if min_f is None:
                         min_f = max_f
                     if max_f is None:
                         max_f = min_f
                     if min_f is None or max_f is None:
                         return "-"
                     source_min = min_val if min_val is not None else max_val
                     source_max = max_val if max_val is not None else min_val
                     if source_min is None or source_max is None:
                         return "-"
                     try:
                         min_float = float(source_min)
                         max_float = float(source_max)
                     except (TypeError, ValueError):
                         return "-"
                     if not math.isfinite(min_float) or not math.isfinite(max_float):
                         return "-"
                     if tolerance and abs(max_float - min_float) <= tolerance:
                         return fmt.format(max_float)
                     if abs(max_float - min_float) <= 1e-12:
                         return fmt.format(max_float)
-                    return f"{fmt.format(min_float)}–{fmt.format(max_float)}"
+                    return fmt_range(
+                        min_float,
+                        max_float,
+                        formatter=lambda val: fmt.format(float(val)),
+                    )
 
                 sfm_avg = _avg_value("sfm_sum", "sfm_count")
                 rpm_avg = _avg_value("rpm_sum", "rpm_count")
                 ipm_avg = _avg_value("ipm_sum", "ipm_count")
                 summary["rpm"] = rpm_avg
                 summary["ipm"] = ipm_avg
                 summary["minutes_per_hole"] = minutes_avg
                 sfm_text = _format_range(
                     summary.get("sfm_min"), summary.get("sfm_max"), "{:.0f}", tolerance=0.5
                 )
                 if sfm_text == "-":
                     sfm_text = _format_avg(sfm_avg, "{:.0f}")
                 ipr_min_val = summary.get("ipr_effective_min")
                 if ipr_min_val is None:
                     ipr_min_val = summary.get("ipr_min")
                 ipr_max_val = summary.get("ipr_effective_max")
                 if ipr_max_val is None:
                     ipr_max_val = summary.get("ipr_max")
                 ipr_text = _format_range(ipr_min_val, ipr_max_val, "{:.4f}", tolerance=5e-5)
                 rpm_text = _format_range(summary.get("rpm_min"), summary.get("rpm_max"), "{:.0f}", tolerance=0.5)
                 ipm_text = _format_range(summary.get("ipm_min"), summary.get("ipm_max"), "{:.1f}", tolerance=0.05)
 
                 diam_qty = summary.get("diameter_qty_sum", 0) or 0
                 dia_segment = "Ø -"
                 if diam_qty > 0:
@@ -14781,51 +14792,55 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
                         line,
                         count=1,
                     )
                 )
             else:
                 updated_debug_lines.append(line)
         drill_debug_lines[:] = updated_debug_lines
         material_display_for_debug = final_material_for_debug
         material_selection["canonical_material"] = final_material_for_debug
         material_selection["canonical"] = final_material_for_debug
         if final_material_for_debug:
             canonical_material = str(final_material_for_debug).strip() or canonical_material
             material_selected_summary["canonical"] = canonical_material
 
     drill_debug_line: str | None = None
     if (speeds_feeds_summary or speeds_feeds_row) and avg_dia_in > 0:
         def _format_range_text(values: Sequence[float], fmt: str, *, tolerance: float = 0.0) -> str:
             if not values:
                 return "-"
             min_val = min(values)
             max_val = max(values)
             if tolerance and abs(max_val - min_val) <= tolerance:
                 return fmt.format(max_val)
             if abs(max_val - min_val) <= 1e-12:
                 return fmt.format(max_val)
-            return f"{fmt.format(min_val)}–{fmt.format(max_val)}"
+            return fmt_range(
+                min_val,
+                max_val,
+                formatter=lambda val: fmt.format(float(val)),
+            )
 
         def _coerce_numeric(value: Any) -> float | None:
             coerced = _coerce_float_or_none(value)
             if coerced is None or not math.isfinite(float(coerced)):
                 return None
             return float(coerced)
 
         rpm_values: list[float] = []
         ipm_values: list[float] = []
         ipr_values: list[float] = []
         sfm_values: list[float] = []
 
         bins_mapping: Mapping[str, Any] | None = None
         if isinstance(speeds_feeds_summary, _MappingABC):
             bins_candidate = speeds_feeds_summary.get("bins")
             if isinstance(bins_candidate, _MappingABC):
                 bins_mapping = bins_candidate
         if bins_mapping:
             for bin_summary in bins_mapping.values():
                 if not isinstance(bin_summary, _MappingABC):
                     continue
                 dia_val = _coerce_float_or_none(bin_summary.get("diameter_in"))
                 if dia_val is None or dia_val <= 0:
                     continue
                 speeds_map = bin_summary.get("speeds")
@@ -15543,51 +15558,51 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
         if isinstance(process_plan_summary, dict)
         else {}
     )
     pass_through = _build_pass_through(
         planner_directs,
         material_direct_cost=material_direct_cost,
         shipping_cost=shipping_cost,
         hardware_cost=hardware_cost,
         outsourced_costs=outsourced_costs,
         include_outsourced_pass=include_outsourced_pass,
         utilities_cost=utilities_cost,
         consumables_flat=consumables_flat,
         packaging_flat_base=packaging_flat_base,
         material_scrap_credit_applied=material_scrap_credit_applied,
     )
     pass_through[_canonical_pass_label("Material")] = float(material_direct_cost)
     pass_through_baseline = {k: float(v) for k, v in pass_through.items()}
 
     fix_detail = nre_detail.get("fixture", {})
     fixture_plan_desc = None
     try:
         fb = float(fixture_build_hr)
     except Exception:
         fb = 0.0
     if fb:
-        fixture_plan_desc = f"{fb:.2f} hr build"
+        fixture_plan_desc = f"{fmt_hours(fb)} build"
     strategy = fix_detail.get("strategy") if isinstance(fix_detail, dict) else None
     if isinstance(strategy, str) and strategy.strip():
         if fixture_plan_desc:
             fixture_plan_desc = f"{fixture_plan_desc} ({strategy.strip()})"
         else:
             fixture_plan_desc = strategy.strip()
 
     fixture_build_hr_base = float(fixture_build_hr or 0.0)
     cmm_minutes_base = float((cmm_run_hr or 0.0) * 60.0)
     inproc_hr_base = float(inproc_hr or 0.0)
     packaging_hr_base = float(packaging_hr or 0.0)
     fai_flag_base = False
     if isinstance(ui_vars, dict):
         raw_fai = ui_vars.get("FAIR Required")
         fai_flag_base = _coerce_checkbox_state(raw_fai, False)
 
     def _clean_stock_entry(entry: dict[str, Any]) -> dict[str, Any]:
         cleaned: dict[str, Any] = {}
         for k, v in entry.items():
             key = str(k)
             if isinstance(v, (str, int, float, bool)) or v is None:
                 cleaned[key] = v
             else:
                 try:
                     cleaned[key] = float(v)
@@ -16923,51 +16938,51 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
         fixture_labor_per_part = (
             fixture_labor_cost / Qty if Qty > 1 else fixture_labor_cost
         )
         fixture_per_part = (
             fixture_cost / Qty if Qty > 1 else fixture_cost
         )
         fixture_entry = nre_detail.setdefault("fixture", {})
         fixture_entry.update(
             {
                 "build_hr": float(fixture_build_hr),
                 "build_rate": fixture_rate,
                 "labor_cost": float(fixture_labor_cost),
                 "per_lot": float(fixture_cost),
                 "per_part": float(fixture_per_part),
             }
         )
         features["fixture_build_hr"] = float(fixture_build_hr)
         fixture_build_hr_base = float(fixture_build_hr or 0.0)
         fixture_plan_desc = None
         strategy_text = None
         if isinstance(fixture_entry, _MappingABC):
             strategy_value = fixture_entry.get("strategy")
             if isinstance(strategy_value, str):
                 strategy_text = strategy_value.strip()
         if fixture_build_hr > 0:
-            fixture_plan_desc = f"{fixture_build_hr:.2f} hr build"
+            fixture_plan_desc = f"{fmt_hours(fixture_build_hr)} build"
         if strategy_text:
             if fixture_plan_desc:
                 fixture_plan_desc = f"{fixture_plan_desc} ({strategy_text})"
             else:
                 fixture_plan_desc = strategy_text
 
     baseline_data = {
         "process_hours": process_hours_baseline,
         "pass_through": pass_through_baseline,
         "scrap_pct": scrap_pct_baseline,
         "setups": int(setups),
         "contingency_pct": ContingencyPct,
         "fixture_build_hr": fixture_build_hr_base,
         "soft_jaw_hr": 0.0,
         "soft_jaw_material_cost": 0.0,
         "handling_adder_hr": 0.0,
         "cmm_minutes": cmm_minutes_base,
         "in_process_inspection_hr": inproc_hr_base,
         "inspection_total_hr": inspection_hr_total,
         "inspection_components": {k: float(v) for k, v in inspection_components.items()},
         "fai_required": fai_flag_base,
         "fai_prep_hr": 0.0,
         "packaging_hours": packaging_hr_base,
         "packaging_flat_cost": packaging_flat_base,
         "shipping_cost": shipping_cost_base,
@@ -17719,107 +17734,119 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
     def _normalize_key(name: str) -> str:
         return re.sub(r"[^a-z0-9]+", "_", str(name).lower()).strip("_")
 
     process_key_map = {_normalize_key(k): k for k in process_costs.keys()}
     pass_key_map = {
         _normalize_key(_canonical_pass_label(k)): _canonical_pass_label(k)
         for k in pass_through.keys()
     }
 
     def _friendly_process(name: str) -> str:
         return name.replace("_", " ").title()
 
     def _cost_of(proc_key: str, hours: float) -> float:
         parts = proc_key.replace("_", " ").split()
         rate_key = "".join(part.title() for part in parts) + "Rate"
         return float(hours) * float(rates.get(rate_key, rates.get("MillingRate", 120.0)))
 
     fixture_notes: list[str] = []
     fixture_build_override = _clamp_override((overrides or {}).get("fixture_build_hr"), 0.0, 2.0)
     soft_jaw_hr_override = _clamp_override((overrides or {}).get("soft_jaw_hr"), 0.0, 1.0) or 0.0
     soft_jaw_cost_override = _clamp_override((overrides or {}).get("soft_jaw_material_cost"), 0.0, 60.0) or 0.0
 
     total_fixture_hr = fixture_build_override if fixture_build_override is not None else fixture_build_hr_base
     if soft_jaw_hr_override > 0:
         total_fixture_hr += soft_jaw_hr_override
-        fixture_notes.append(f"Soft jaw prep +{soft_jaw_hr_override:.2f} h{_source_suffix('soft_jaw_hr')}")
+        fixture_notes.append(
+            f"Soft jaw prep +{fmt_hours(soft_jaw_hr_override, unit='h')}{_source_suffix('soft_jaw_hr')}"
+        )
     if fixture_build_override is not None:
-        fixture_notes.append(f"Fixture build set to {fixture_build_override:.2f} h{_source_suffix('fixture_build_hr')}")
+        fixture_notes.append(
+            f"Fixture build set to {fmt_hours(fixture_build_override, unit='h')}{_source_suffix('fixture_build_hr')}"
+        )
 
     if soft_jaw_cost_override > 0:
-        fixture_notes.append(f"Soft jaw stock +${soft_jaw_cost_override:,.2f}{_source_suffix('soft_jaw_material_cost')}")
+        fixture_notes.append(
+            f"Soft jaw stock +{fmt_money(soft_jaw_cost_override, '$')}{_source_suffix('soft_jaw_material_cost')}"
+        )
 
     if total_fixture_hr != fixture_build_hr_base or soft_jaw_cost_override > 0:
         fixture_build_hr = total_fixture_hr
         fixture_labor_cost = fixture_build_hr * float(rates.get("FixtureBuildRate", 0.0))
         fixture_cost = fixture_labor_cost
         fixture_labor_per_part = (fixture_labor_cost / Qty) if Qty > 1 else fixture_labor_cost
         fixture_per_part = (fixture_cost / Qty) if Qty > 1 else fixture_cost
         nre_detail.setdefault("fixture", {})
         nre_detail["fixture"].update(
             {
                 "build_hr": float(fixture_build_hr),
                 "labor_cost": float(fixture_labor_cost),
                 "per_lot": float(fixture_cost),
                 "per_part": float(fixture_per_part),
                 "soft_jaw_hr": float(soft_jaw_hr_override),
                 "soft_jaw_mat": float(soft_jaw_cost_override),
             }
         )
         features["fixture_build_hr"] = float(fixture_build_hr)
 
     handling_override = _clamp_override((overrides or {}).get("handling_adder_hr"), 0.0, 0.2)
     if handling_override and handling_override > 0:
         base_milling_hr = float(process_meta.get("milling", {}).get("hr", 0.0))
         _update_process_hours(
             "milling",
             base_milling_hr + handling_override,
-            f"+{handling_override:.2f} h handling{_source_suffix('handling_adder_hr')}",
+            f"+{fmt_hours(handling_override, unit='h')} handling{_source_suffix('handling_adder_hr')}",
+        )
+        llm_notes.append(
+            f"Handling adder +{fmt_hours(handling_override, unit='h')}{_source_suffix('handling_adder_hr')}"
         )
-        llm_notes.append(f"Handling adder +{handling_override:.2f} h{_source_suffix('handling_adder_hr')}")
 
     packaging_hours_override = _clamp_override((overrides or {}).get("packaging_hours"), 0.0, 0.5)
     if packaging_hours_override is not None:
         _update_process_hours(
             "packaging",
             packaging_hours_override,
-            f"Packaging set to {packaging_hours_override:.2f} h{_source_suffix('packaging_hours')}",
+            f"Packaging set to {fmt_hours(packaging_hours_override, unit='h')}{_source_suffix('packaging_hours')}",
         )
 
     packaging_flat_override = _clamp_override((overrides or {}).get("packaging_flat_cost"), 0.0, 25.0)
     if packaging_flat_override is not None:
         baseline_val = float(pass_through_baseline.get("Packaging Flat", 0.0))
         entry = applied_pass.setdefault("Packaging Flat", {"old_value": baseline_val, "notes": []})
-        entry["notes"].append(f"set to ${packaging_flat_override:,.2f}{_source_suffix('packaging_flat_cost')}")
+        entry["notes"].append(
+            f"set to {fmt_money(packaging_flat_override, '$')}{_source_suffix('packaging_flat_cost')}"
+        )
         entry["new_value"] = float(packaging_flat_override)
         pass_through["Packaging Flat"] = float(packaging_flat_override)
 
     shipping_override = _clamp_override((overrides or {}).get("shipping_cost"), 0.0, None)
     if shipping_override is not None:
         baseline_val = float(pass_through_baseline.get("Shipping", shipping_cost_base))
         entry = applied_pass.setdefault("Shipping", {"old_value": baseline_val, "notes": []})
-        entry["notes"].append(f"set to ${shipping_override:,.2f}{_source_suffix('shipping_cost')}")
+        entry["notes"].append(
+            f"set to {fmt_money(shipping_override, '$')}{_source_suffix('shipping_cost')}"
+        )
         entry["new_value"] = float(shipping_override)
         pass_through["Shipping"] = float(shipping_override)
         pass_key_map[_normalize_key("Shipping")] = "Shipping"
         pass_meta.setdefault("Shipping", {})["basis"] = "Outbound freight & logistics (user override)"
 
     cmm_minutes_override = _clamp_override((overrides or {}).get("cmm_minutes"), 0.0, 60.0)
     if cmm_minutes_override is not None:
         base_cmm_hr = float(cmm_run_hr or 0.0)
         target_cmm_hr = float(cmm_minutes_override) / 60.0
         total_inspection_hr = float(process_meta.get("inspection", {}).get("hr", 0.0))
         adjusted_hr = max(0.0, total_inspection_hr - base_cmm_hr + target_cmm_hr)
         _update_process_hours(
             "inspection",
             adjusted_hr,
             f"CMM {target_cmm_hr:.2f} h{_source_suffix('cmm_minutes')}",
         )
         llm_notes.append(f"CMM runtime {target_cmm_hr:.2f} h{_source_suffix('cmm_minutes')}")
         delta_cmm = target_cmm_hr - base_cmm_hr
         if abs(delta_cmm) > 1e-9:
             inspection_adjustments["cmm_run"] = inspection_adjustments.get("cmm_run", 0.0) + delta_cmm
         cmm_run_hr = target_cmm_hr
 
     inproc_override = _clamp_override((overrides or {}).get("in_process_inspection_hr"), 0.0, 0.5)
     if inproc_override and inproc_override > 0:
         current_inspection_hr = float(process_meta.get("inspection", {}).get("hr", 0.0))
@@ -17932,77 +17959,77 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
 
     if change_triggered:
         baseline = float(features.get("material_cost_baseline", material_direct_cost_base))
         scaled = round(baseline * total_scale, 2)
         pass_through["Material"] = scaled
         entry = applied_pass.setdefault("Material", {"old_value": float(material_direct_cost_base), "notes": []})
         if removal_applied and removal_lb is not None:
             entry["notes"].append(f"material removal -{removal_lb:.2f} lb")
         elif removal_applied:
             entry["notes"].append(f"material removal -{removal_mass_g:.1f} g")
         if scrap_changed:
             src_tag = (
                 quote_state.effective_sources.get("scrap_pct")
                 if quote_state and isinstance(quote_state.effective_sources, dict)
                 else None
             )
             suffix = ""
             if scrap_override_applied:
                 if src_tag == "user":
                     suffix = " (user override)"
                 elif src_tag == "llm":
                     suffix = " (LLM)"
             elif removal_applied:
                 suffix = " (material removal)"
             entry["notes"].append(
-                f"scrap {old_scrap * 100:.1f}% → {scrap_after * 100:.1f}%{suffix}"
+                f"scrap {fmt_percent(old_scrap)} → {fmt_percent(scrap_after)}{suffix}"
             )
         entry["new_value"] = scaled
 
         if removal_applied:
             removal_note = (
                 f"Material removal -{removal_lb:.2f} lb → net {net_after / 1000.0 * LB_PER_KG:.2f} lb"
                 if removal_lb is not None
                 else f"Material removal -{removal_mass_g:.1f} g"
             )
             llm_notes.append(removal_note)
         if scrap_changed:
             src_tag = (
                 quote_state.effective_sources.get("scrap_pct")
                 if quote_state and isinstance(quote_state.effective_sources, dict)
                 else None
             )
             suffix = ""
             if scrap_override_applied:
                 if src_tag == "user":
                     suffix = " (user override)"
                 elif src_tag == "llm":
                     suffix = " (LLM)"
             elif removal_applied:
                 suffix = " (material removal)"
             llm_notes.append(
-                f"Scrap {old_scrap * 100:.1f}% → {scrap_after * 100:.1f}%{suffix}"
+                f"Scrap {fmt_percent(old_scrap)} → {fmt_percent(scrap_after)}{suffix}"
             )
 
         features["scrap_pct"] = scrap_after
         if removal_applied:
             features["material_removed_mass_g"] = removal_mass_g
             features["net_mass_g"] = net_after
 
     scrap_pct = scrap_after
     material_detail_for_breakdown["mass_g_net"] = net_after
     material_detail_for_breakdown["net_mass_g"] = net_after
     material_detail_for_breakdown["effective_mass_g"] = effective_mass_after
     material_detail_for_breakdown["mass_g"] = effective_mass_after
     material_detail_for_breakdown["scrap_pct"] = scrap_pct
     if change_triggered:
         material_detail_for_breakdown["material_cost"] = pass_through.get(
             "Material", material_detail_for_breakdown.get("material_cost")
         )
         material_detail_for_breakdown["material_direct_cost"] = pass_through.get(
             "Material", material_detail_for_breakdown.get("material_direct_cost")
         )
 
     material_detail_for_breakdown["scrap_pct"] = scrap_pct
 
     src_mult_map = {}
     if isinstance(quote_state.effective_sources, dict):
@@ -18058,110 +18085,110 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
         if norm_key == "deep_drill":
             norm_key = "drilling"
         actual = process_key_map.get(norm_key)
         bucket_cap = bucket_caps_bound.get(str(key).lower())
         if bucket_cap is None and actual is not None:
             bucket_cap = bucket_caps_bound.get(str(actual).lower())
         limit = bucket_cap if bucket_cap is not None else adder_max_bound
         add_hr = clamp(add_hr, adder_min_bound, limit, adder_min_bound)
         if add_hr <= 0:
             continue
         if not actual:
             continue
         entry = applied_process.setdefault(
             actual,
             {
                 "old_hr": float(process_meta.get(actual, {}).get("hr", 0.0)),
                 "old_cost": float(process_costs.get(actual, 0.0)),
                 "notes": [],
             },
         )
         delta_cost = _cost_of(actual, add_hr)
         process_costs[actual] = round(float(process_costs.get(actual, 0.0)) + delta_cost, 2)
         meta = process_meta.get(actual)
         if meta:
             meta["hr"] = float(meta.get("hr", 0.0)) + float(add_hr)
-        entry["notes"].append(f"+{float(add_hr):.2f} hr")
+        entry["notes"].append(f"+{fmt_hours(add_hr)}")
         entry["new_hr"] = float(process_meta.get(actual, {}).get("hr", entry["old_hr"]))
         entry["new_cost"] = process_costs[actual]
         src_tag = src_add_map.get(key)
         suffix = ""
         if src_tag == "user":
             suffix = " (user override)"
         elif src_tag == "llm":
             suffix = " (LLM)"
-        llm_notes.append(f"{_friendly_process(actual)} +{float(add_hr):.2f} hr{suffix}")
+        llm_notes.append(f"{_friendly_process(actual)} +{fmt_hours(add_hr)}{suffix}")
 
     src_pass_map: dict[str, Any] = {}
     if isinstance(quote_state.effective_sources, dict):
         raw_src_pass = quote_state.effective_sources.get("add_pass_through") or {}
         if isinstance(raw_src_pass, _MappingABC):
             for key, value in raw_src_pass.items():
                 canon_key = _canonical_pass_label(key)
                 if canon_key:
                     src_pass_map[canon_key] = value
     add_pass_raw = overrides.get("add_pass_through") if overrides else {}
     add_pass = canonicalize_pass_through_map(add_pass_raw)
     for label, add_val in (add_pass or {}).items():
         if not isinstance(add_val, (int, float)):
             continue
         add_val = clamp(add_val, 0.0, 200.0, 0.0)
         if add_val <= 0:
             continue
         actual_label = pass_key_map.get(_normalize_key(label), str(label))
         old_val = float(pass_through.get(actual_label, 0.0))
         new_val = round(old_val + float(add_val), 2)
         pass_through[actual_label] = new_val
         pass_key_map[_normalize_key(actual_label)] = actual_label
         entry = applied_pass.setdefault(actual_label, {"old_value": old_val, "notes": []})
-        entry["notes"].append(f"+${float(add_val):,.2f}")
+        entry["notes"].append(f"+{fmt_money(add_val, '$')}")
         entry["new_value"] = new_val
         if actual_label not in pass_meta:
             pass_meta[actual_label] = {"basis": "LLM override"}
         src_tag = src_pass_map.get(actual_label)
         suffix = ""
         if src_tag == "user":
             suffix = " (user override)"
         elif src_tag == "llm":
             suffix = " (LLM)"
-        llm_notes.append(f"{actual_label}: +${float(add_val):,.0f}{suffix}")
+        llm_notes.append(f"{actual_label}: +{fmt_money(add_val, '$')}{suffix}")
 
     cont_override = overrides.get("contingency_pct_override") if overrides else None
     if cont_override is not None:
         cont_val = clamp(cont_override, 0.0, 0.25, ContingencyPct)
         if cont_val is not None:
             ContingencyPct = float(cont_val)
             params["ContingencyPct"] = ContingencyPct
             src_tag = None
             if isinstance(quote_state.effective_sources, dict):
                 src_tag = quote_state.effective_sources.get("contingency_pct")
             suffix = ""
             if src_tag == "user":
                 suffix = " (user override)"
             elif src_tag == "llm":
                 suffix = " (LLM)"
-            llm_notes.append(f"Contingency set to {ContingencyPct * 100:.1f}%{suffix}")
+            llm_notes.append(f"Contingency set to {fmt_percent(ContingencyPct)}{suffix}")
 
     for label, value in list(pass_through.items()):
         try:
             pass_through[label] = round(float(value), 2)
         except Exception:
             pass_through[label] = 0.0
 
     try:
         setups_for_cap = float(setups)
     except Exception:
         setups_for_cap = 1.0
     if not math.isfinite(setups_for_cap) or setups_for_cap <= 0:
         setups_for_cap = 1.0
     hour_ceiling = max(0.0, 24.0 * setups_for_cap)
 
     def _collect_process_hours() -> dict[str, float]:
         bounded: dict[str, float] = {}
         for key, meta in process_meta.items():
             raw_val: Any = meta
             if isinstance(meta, _MappingABC):
                 raw_val = meta.get("hr", 0.0)
             try:
                 hr_val = float(raw_val or 0.0)
             except Exception:
                 hr_val = 0.0
@@ -18927,51 +18954,51 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
         if eng_hr_detail > 0:
             programming_bits.append(
                 f"- Engineering (lot): {_hours_with_rate_text(eng_hr_detail, eng_rate_detail)}"
             )
         programming_bits.append(f"Amortized across {Qty} pcs")
 
         _merge_labor_detail("Programming (amortized)", programming_per_part, programming_bits)
         if programming_bits:
             detail_lookup["Programming (amortized)"] = "; ".join(programming_bits)
 
     show_fixture_amortized = Qty > 1 and fixture_labor_per_part > 0
     fixture_bits: list[str] | None = None
     if show_fixture_amortized:
         fixture_bits = []
         fixture_detail = nre_detail.get("fixture", {}) if isinstance(nre_detail, dict) else {}
         fixture_build_hr_detail = float(fixture_detail.get("build_hr", 0.0) or 0.0)
         fixture_rate_detail = float(
             fixture_detail.get("build_rate", rates.get("FixtureBuildRate", 0.0))
         )
         if fixture_build_hr_detail > 0:
             fixture_bits.append(
                 f"- Build labor (lot): {_hours_with_rate_text(fixture_build_hr_detail, fixture_rate_detail)}"
             )
         soft_jaw_hr = float(fixture_detail.get("soft_jaw_hr", 0.0) or 0.0)
         if soft_jaw_hr > 0:
-            fixture_bits.append(f"Soft jaw prep {soft_jaw_hr:.2f} hr")
+            fixture_bits.append(f"Soft jaw prep {fmt_hours(soft_jaw_hr)}")
         fixture_bits.append(f"Amortized across {Qty} pcs")
 
         _merge_labor_detail("Fixture Build (amortized)", fixture_labor_per_part, fixture_bits)
         if fixture_bits:
             detail_lookup["Fixture Build (amortized)"] = "; ".join(fixture_bits)
 
     proc_total_val: float | None
     if "proc_total" in locals():
         try:
             proc_total_val = float(locals().get("proc_total", 0.0) or 0.0)
         except Exception:
             proc_total_val = 0.0
     else:
         proc_total_val = None
 
     if proc_total_val is None:
         try:
             proc_total_val = float(
                 sum(float(value or 0.0) for value in labor_costs_display.values())
             )
         except Exception:
             proc_total_val = 0.0
 
     rendered_labor_total = float(proc_total_val or 0.0)
     expected_labor_total = float(labor_cost or 0.0)
@@ -19017,100 +19044,102 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
             try:
                 qty_for_reconcile_int = int(float(qty_for_reconcile or 0.0))
             except Exception:
                 qty_for_reconcile_int = 0
 
         base_labor_val = display_labor_val - amortized_total_val
         if base_labor_val < 0.0 and abs(base_labor_val) <= _PLANNER_BUCKET_ABS_EPSILON:
             base_labor_val = 0.0
         base_labor_val = max(base_labor_val, 0.0)
 
         planner_rendered_total = base_labor_val + display_machine_val
         if qty_for_reconcile_int > 1:
             planner_rendered_total += amortized_total_val
 
         if not roughly_equal(
             planner_rendered_total,
             planner_totals_cost_float,
             eps=_PLANNER_BUCKET_ABS_EPSILON,
         ):
             drift_amount = planner_totals_cost_float - planner_rendered_total
             logger.warning(
                 "Planner rendered totals drifted: %.2f vs %.2f",
                 planner_rendered_total,
                 planner_totals_cost_float,
             )
+            drift_display = fmt_money(abs(drift_amount), "$")
+            rendered_display = fmt_money(planner_rendered_total, "$")
+            planner_display = fmt_money(planner_totals_cost_float, "$")
             _record_red_flag(
                 "⚠️ Planner totals drifted by "
-                f"${abs(drift_amount):,.2f}: rendered ${planner_rendered_total:,.2f} "
-                f"vs planner ${planner_totals_cost_float:,.2f}"
+                f"{drift_display}: rendered {rendered_display} vs planner {planner_display}"
             )
             proc_total_val = expected_labor_total
             rendered_labor_total = expected_labor_total
     elif abs(rendered_labor_total - expected_labor_total) > _LABOR_SECTION_ABS_EPSILON:
         narrative_notes.append(
-            f"Note: labor total adjusted (expected ${expected_labor_total:,.2f})."
+            f"Note: labor total adjusted (expected {fmt_money(expected_labor_total, '$')})."
         )
 
     try:
         labor_display_total = sum(float(value or 0.0) for value in labor_costs_display.values())
     except Exception:  # pragma: no cover - defensive logging
         logger.exception("Labor section invariant calculation failed")
     else:
         recomputed_labor_total = round(rendered_labor_total, 2)
         if not math.isclose(
             recomputed_labor_total,
             expected_labor_total,
             rel_tol=0.0,
             abs_tol=_LABOR_SECTION_ABS_EPSILON,
         ):
             logger.warning(
                 "Labor section totals drifted: %.2f vs %.2f",
                 recomputed_labor_total,
                 expected_labor_total,
             )
             if not math.isclose(
                 labor_display_total,
                 expected_labor_total,
                 rel_tol=0.0,
                 abs_tol=_LABOR_SECTION_ABS_EPSILON,
             ):
                 try:
                     logger.debug(
                         "Labor display components: %.2f vs expected %.2f",
                         labor_display_total,
                         expected_labor_total,
                     )
                 except Exception:
                     pass
 
         if pricing_source != "planner" and abs(rendered_labor_total - float(expected_labor_total)) > _LABOR_SECTION_ABS_EPSILON:
             expected_display = float(expected_labor_total)
             drift_amount = expected_display - rendered_labor_total
             _record_red_flag(
-                f"⚠️ Labor totals drifted by ${drift_amount:,.2f}: "
-                f"rendered ${rendered_labor_total:,.2f} vs expected ${expected_display:,.2f}"
+                f"⚠️ Labor totals drifted by {fmt_money(drift_amount, '$')}: "
+                f"rendered {fmt_money(rendered_labor_total, '$')} vs expected {fmt_money(expected_display, '$')}"
             )
 
         labor_cost = recomputed_labor_total
 
         insurance_cost = insurance_pct * (labor_cost + base_direct_costs)
         vendor_marked_add = vendor_markup * (outsourced_costs + shipping_cost)
         if base_directs_excluding_ship_mat > 0:
             insurance_cost = round(insurance_cost, 2)
             vendor_marked_add = round(vendor_marked_add, 2)
             pass_through["Insurance"] = insurance_cost
             pass_through["Vendor Markup Added"] = vendor_marked_add
         else:
             insurance_cost = 0.0
             vendor_marked_add = 0.0
             pass_through.pop("Insurance", None)
             pass_through.pop("Vendor Markup Added", None)
         total_direct_costs = _compute_direct_costs(
             material_total_for_directs,
             scrap_credit_for_directs,
             material_tax_for_directs,
             pass_through,
         )
         try:
             total_direct_costs_float = float(total_direct_costs)
         except Exception:
@@ -19129,85 +19158,91 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
         direct_costs = float(breakdown.get("total_direct_costs", stored_total_directs))
         _update_direct_costs_summary(direct_costs, labor_cost)
         ladder_subtotal = float(labor_cost) + direct_costs
         subtotal = ladder_subtotal
         if isinstance(breakdown, dict):
             try:
                 breakdown["ladder_subtotal"] = float(ladder_subtotal)
             except Exception:
                 pass
         with_overhead = subtotal * (1.0 + OverheadPct)
         with_ga = with_overhead * (1.0 + GA_Pct)
         with_cont = with_ga * (1.0 + ContingencyPct)
         with_expedite = with_cont * (1.0 + ExpeditePct)
         price_before_margin = with_expedite
         price = price_before_margin * (1.0 + MarginPct)
         price = max(price, min_lot)
 
     direct_costs_display: dict[str, float] = {label: float(value) for label, value in pass_through.items()}
     direct_cost_details: dict[str, str] = {}
     for label, value in direct_costs_display.items():
         detail_bits: list[str] = []
         basis = pass_meta.get(label, {}).get("basis")
         if basis and label != "Material":
             detail_bits.append(f"Basis: {basis}")
         if label == "Insurance":
-            detail_bits.append(f"Applied {insurance_pct:.1%} of labor + directs")
+            detail_bits.append(f"Applied {fmt_percent(insurance_pct)} of labor + directs")
         elif label == "Vendor Markup Added":
-            detail_bits.append(f"Markup {vendor_markup:.1%} on vendors + shipping")
+            detail_bits.append(f"Markup {fmt_percent(vendor_markup)} on vendors + shipping")
         elif label == "Material":
             pass
         pass_notes = applied_pass.get(label, {}).get("notes")
         if pass_notes:
             detail_bits.append("LLM: " + ", ".join(pass_notes))
         if detail_bits:
             direct_cost_details[label] = "; ".join(detail_bits)
 
     prog_detail = nre_detail.get("programming", {})
     fix_detail = nre_detail.get("fixture", {})
     nre_costs_display: dict[str, float] = {}
     nre_cost_details: dict[str, str] = {}
 
     prog_per_lot = float(prog_detail.get("per_lot", 0.0) or 0.0)
     if prog_per_lot:
         label = "Programming & Eng (per lot)"
         nre_costs_display[label] = prog_per_lot
         details = []
         if prog_detail.get("prog_hr"):
-            details.append(f"Programmer {prog_detail['prog_hr']:.2f} hr @ ${prog_detail.get('prog_rate',0):,.2f}/hr")
+            details.append(
+                f"Programmer {fmt_hours(prog_detail['prog_hr'])} @ {fmt_money(prog_detail.get('prog_rate', 0), '$')}/hr"
+            )
         if prog_detail.get("eng_hr"):
-            details.append(f"Engineer {prog_detail['eng_hr']:.2f} hr @ ${prog_detail.get('eng_rate',0):,.2f}/hr")
+            details.append(
+                f"Engineer {fmt_hours(prog_detail['eng_hr'])} @ {fmt_money(prog_detail.get('eng_rate', 0), '$')}/hr"
+            )
         if details:
             nre_cost_details[label] = "; ".join(details)
 
     fix_per_lot = float(fix_detail.get("per_lot", 0.0) or 0.0)
     if fix_per_lot:
         label = "Fixturing (per lot)"
         nre_costs_display[label] = fix_per_lot
         details = []
         if fix_detail.get("build_hr"):
-            details.append(f"Build {fix_detail['build_hr']:.2f} hr @ ${fix_detail.get('build_rate',0):,.2f}/hr")
+            details.append(
+                f"Build {fmt_hours(fix_detail['build_hr'])} @ {fmt_money(fix_detail.get('build_rate', 0), '$')}/hr"
+            )
         if details:
             nre_cost_details[label] = "; ".join(details)
 
     applied_multipliers_log: dict[str, float] = {}
     for key, value in (overrides.get("process_hour_multipliers") or {}).items():
         actual = process_key_map.get(_normalize_key(key), key)
         try:
             applied_multipliers_log[actual] = float(value)
         except Exception:
             applied_multipliers_log[actual] = value
 
     applied_adders_log: dict[str, float] = {}
     for key, value in (overrides.get("process_hour_adders") or {}).items():
         actual = process_key_map.get(_normalize_key(key), key)
         try:
             applied_adders_log[actual] = float(value)
         except Exception:
             applied_adders_log[actual] = value
 
     llm_cost_log = {
         "overrides": overrides,
         "applied_process": applied_process,
         "applied_pass": applied_pass,
         "scrap_pct": scrap_pct,
         "baseline_process_hours": process_hours_baseline,
@@ -19374,52 +19409,52 @@ def _compute_quote_from_df_impl(  # type: ignore[reportGeneralTypeIssues]
             except Exception:
                 breakdown["total_direct_costs"] = total_direct_costs_value
 
     try:
         breakdown["ladder_subtotal"] = float(labor_cost) + float(
             breakdown.get("total_direct_costs", 0.0) or 0.0
         )
     except Exception:
         pass
 
     totals_map = breakdown.get("totals")
     if isinstance(totals_map, _MutableMappingABC):
         for key, value in totals_summary.items():
             try:
                 totals_map[key] = float(value)
             except Exception:
                 totals_map[key] = value
     elif totals_summary:
         breakdown["totals"] = {
             key: float(value) if isinstance(value, (int, float)) else value
             for key, value in totals_summary.items()
         }
 
     breakdown["labor_cost_rendered"] = rendered_labor_total
     narrative_notes.append(
-        f"  Cost makeup: material ${material_total_for_why:,.2f}; labor & machine "
-        f"${breakdown.get('labor_cost_rendered', labor_cost):,.2f}."
+        f"  Cost makeup: material {fmt_money(material_total_for_why, currency)}; labor & machine "
+        f"{fmt_money(breakdown.get('labor_cost_rendered', labor_cost), currency)}."
     )
 
     breakdown["pricing_source"] = pricing_source_decision
     if red_flag_messages:
         breakdown["red_flags"] = list(red_flag_messages)
     if suppress_planner_details_due_to_drift:
         breakdown["suppress_planner_details_due_to_drift"] = True
     planner_bucket_display_map_breakdown: dict[str, dict[str, Any]] | None = None
     if planner_bucket_view is not None:
         planner_bucket_display_map_breakdown = _extract_bucket_map(planner_bucket_view)
         breakdown["bucket_view"] = copy.deepcopy(planner_bucket_view)
         if planner_bucket_display_map_breakdown:
             breakdown["planner_bucket_display_map"] = copy.deepcopy(
                 planner_bucket_display_map_breakdown
             )
     if planner_bucket_rollup is not None:
         breakdown["planner_bucket_rollup"] = copy.deepcopy(planner_bucket_rollup)
     if planner_bucket_display_map_payload:
         breakdown["planner_bucket_display_map"] = copy.deepcopy(
             planner_bucket_display_map_payload
         )
 
     if process_plan_summary:
         breakdown["process_plan"] = copy.deepcopy(process_plan_summary)
     if planner_process_minutes is not None:
@@ -21223,51 +21258,56 @@ def derive_inference_knobs(
                 "process_hour_adders.inspection",
                 "process_hour_multipliers.milling",
             ],
         }
 
     # --- Material & heat treat -----------------------------------------------
     material_signals: list[str] = []
     mat_family = None
     density = None
     price_class = None
     hardness_range = None
     heat_treat_required = False
     if isinstance(material_info, dict):
         mat_note = material_info.get("material_note")
         if mat_note:
             material_signals.append(mat_note)
         mat_family = material_info.get("material_family")
         density = material_info.get("density_g_cc")
         price_class = material_info.get("material_price_class")
         hardness_range = material_info.get("hardness_hrc_range")
         heat_treat_required = bool(material_info.get("heat_treat_required"))
         for line in material_info.get("heat_treat_notes", []) or []:
             material_signals.append(line)
         if hardness_range:
             lo, hi = hardness_range
-            material_signals.append(f"Hardness target {lo:.0f}–{hi:.0f} HRC" if lo != hi else f"Hardness target {lo:.0f} HRC")
+            if lo != hi:
+                material_signals.append(
+                    f"Hardness target {fmt_range(lo, hi, formatter=lambda v: f'{float(v):.0f}', unit='HRC')}"
+                )
+            else:
+                material_signals.append(f"Hardness target {float(lo):.0f} HRC")
         if heat_treat_required and "HEAT TREAT" not in material_signals:
             material_signals.append("HEAT TREAT callout")
     if material_signals:
         wear_multiplier = 1.0
         if hardness_range:
             hi = hardness_range[1]
             wear_multiplier = 1.15 if hi >= 55 else 1.1
         elif heat_treat_required:
             wear_multiplier = 1.1
         heat_treat_pass = 0.0
         if heat_treat_required:
             heat_treat_pass = 120.0
         knobs["material_heat_treat"] = {
             "confidence": "high",
             "signals": material_signals,
             "recommended": {
                 "material_family": mat_family,
                 "density_g_cc": density,
                 "price_class": price_class,
                 "heat_treat_pass_through": round(heat_treat_pass, 2) if heat_treat_pass else None,
                 "milling_tool_wear_multiplier": round(wear_multiplier, 3),
             },
             "targets": [
                 "density_g_cc",
                 "add_pass_through.Outsourced Vendors",
@@ -22877,52 +22917,52 @@ def get_llm_quote_explanation(result: Mapping[str, Any], model_path: str) -> str
                 if top_bits:
                     top_text = "Top processes: " + ", ".join(top_bits) + ". "
 
             geo_text = ""
             if geo_notes:
                 geo_text = "Geometry: " + ", ".join(geo_notes) + ". "
 
             scrap_display = typing.cast(float | None, material_struct.get("scrap_pct"))
             if scrap_display is None:
                 scrap_display = _to_float(ctx.get("scrap_pct"))
             if scrap_display is None:
                 scrap_display = 0.0
             try:
                 scrap_str = f"{float(scrap_display):.1f}"
             except Exception:
                 scrap_str = str(scrap_display)
 
             material_text = ""
             source_val = material_struct.get("source")
             if source_val:
                 material_text = f"Material via {source_val}; scrap {scrap_str}% applied."
             else:
                 material_text = f"Scrap {scrap_str}% applied."
 
             explanation = (
-                f"Labor ${labor_cost:.2f} ({driver_primary['pct_of_subtotal']:.1f}%) and directs "
-                f"${direct_costs:.2f} ({driver_secondary['pct_of_subtotal']:.1f}%) drive cost. "
+                f"Labor {fmt_money(labor_cost, '$')} ({fmt_percent(driver_primary['pct_of_subtotal'])}) and directs "
+                f"{fmt_money(direct_costs, '$')} ({fmt_percent(driver_secondary['pct_of_subtotal'])}) drive cost. "
                 + top_text
                 + geo_text
                 + material_text
             ).strip()
 
         return explanation
 
     if not model_path or not os.path.isfile(model_path):
         return _render_explanation()
 
     system_prompt = (
         "You are a manufacturing estimator. Using ONLY the provided fields, produce a concise JSON explanation.\n"
         "Do not invent numbers. Mention the biggest cost buckets and key geometry drivers if present.\n\n"
         "Return JSON only:\n"
         "{\n"
         '  "explanation": "…1–3 sentences…",\n'
         '  "drivers": [\n'
         '    {"label":"Labor","usd": <number>,"pct_of_subtotal": <number>},\n'
         '    {"label":"Directs","usd": <number>,"pct_of_subtotal": <number>}\n'
         "  ],\n"
         '  "top_processes": [{"name":"drilling","usd": <number>}],\n'
         '  "geo_notes": ["<e.g., 163 holes in 0.25 in steel>"],\n'
         '  "material": {"source":"<string>","scrap_pct": <number>}\n'
         "}"
     )
@@ -25549,51 +25589,51 @@ class App(tk.Tk):
                 ("full", full_report),
             ):
                 widget = self.output_text_widgets.get(name)
                 if widget is None:
                     continue
                 widget.delete("1.0", "end")
                 widget.insert("end", report_text, "rcol")
                 try:
                     widget.mark_set("insert", "1.0")
                     widget.see("1.0")
                 except Exception:
                     pass
 
             try:
                 self.output_nb.select(self.output_tab_simplified)
             except Exception:
                 pass
 
             self.nb.select(self.tab_out)
             try:
                 simp_len = len(simplified_report or "")
                 full_len = len(full_report or "")
             except Exception:
                 simp_len = full_len = 0
             self.status_var.set(
-                f"Quote Generated! Final Price: ${res.get('price', 0):,.2f} (chars: simp={simp_len}, full={full_len})"
+                f"Quote Generated! Final Price: {fmt_money(res.get('price', 0), '$')} (chars: simp={simp_len}, full={full_len})"
             )
             succeeded = True
         finally:
             if succeeded:
                 self._clear_quote_dirty()
             if not already_repricing:
                 self._reprice_in_progress = False
 
 # Helper: map our existing enrich_geo_* output to GEO__ keys
 def _map_geo_to_double_underscore(g: dict) -> dict:
     g = dict(g or {})
     out = {}
     def getf(k):
         try:
             return float(g[k])
         except Exception:
             return None
     L = getf("GEO-01_Length_mm")
     W = getf("GEO-02_Width_mm")
     H = getf("GEO-03_Height_mm")
     if L is not None:
         out["GEO__BBox_X_mm"] = L
     if W is not None:
         out["GEO__BBox_Y_mm"] = W
     if H is not None:
