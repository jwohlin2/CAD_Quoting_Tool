"""Rendering helpers for drilling, tapping, and counterbore reports.

This module contains a pure-python rendering layer that turns normalized
operation groups (as generated by the pricing engine) into the formatted text
report shared by the quoting UI.
"""
from __future__ import annotations

from collections.abc import Iterable, Mapping, Sequence
import math
from typing import Any

Number = float | int


__all__ = [
    "render_drilling_section",
    "render_tapping_section",
    "render_counterbore_section",
]


def _fmt(value: Number, places: int = 2) -> str:
    return f"{float(value):.{places}f}"


def _fmt3(value: Number) -> str:
    return _fmt(value, 3)


def _en_range(values: Iterable[Number | None], places: int = 2) -> str:
    vals = [float(v) for v in values if v is not None]
    if not vals:
        return "-"
    lo = min(vals)
    hi = max(vals)
    if math.isclose(lo, hi, abs_tol=1e-9):
        return _fmt(lo, places)
    return f"{_fmt(lo, places)}–{_fmt(hi, places)}"


def _calc_rpm(sfm: Number | None, dia_in: Number | None) -> float | None:
    if not sfm or not dia_in:
        return None
    return (float(sfm) * 3.82) / float(dia_in)


def _calc_ipm(rpm: float | None, ipr: Number | None) -> float | None:
    if rpm is None or ipr is None:
        return None
    return rpm * float(ipr)


def _aggregate_counts_by_diameter(
    groups: Sequence[Mapping[str, Any]]
) -> dict[float, int]:
    counts: dict[float, int] = {}
    for group in groups:
        dia = group.get("dia")
        qty = group.get("qty")
        if dia is None or qty is None:
            continue
        try:
            dia_val = float(dia)
            qty_int = int(qty)
        except (TypeError, ValueError):
            continue
        if dia_val <= 0 or qty_int <= 0:
            continue
        counts[dia_val] = counts.get(dia_val, 0) + qty_int
    return counts


def _per_diameter_depths(groups: Sequence[Mapping[str, Any]]) -> dict[float, float]:
    totals: dict[float, tuple[float, int]] = {}
    for group in groups:
        dia = group.get("dia")
        depth = group.get("depth_in")
        qty = group.get("qty")
        if dia is None or depth is None or qty is None:
            continue
        try:
            dia_val = float(dia)
            depth_val = float(depth)
            qty_int = int(qty)
        except (TypeError, ValueError):
            continue
        if dia_val <= 0 or qty_int <= 0:
            continue
        acc_depth, acc_qty = totals.get(dia_val, (0.0, 0))
        totals[dia_val] = (acc_depth + depth_val * qty_int, acc_qty + qty_int)

    averages: dict[float, float] = {}
    for dia, (depth_sum, qty_sum) in totals.items():
        if qty_sum > 0:
            averages[dia] = depth_sum / qty_sum
    return averages


def _classify_deep_std(
    per_diam_depth: Mapping[float, float], counts: Mapping[float, int]
) -> tuple[int, int]:
    deep = std = 0
    for diameter, qty in counts.items():
        qty_int = int(qty)
        if qty_int <= 0:
            continue
        depth = per_diam_depth.get(diameter)
        if depth is None:
            continue
        if diameter > 0 and (depth / diameter) >= 3.0:
            deep += qty_int
        else:
            std += qty_int
    return deep, std


def _format_range(lo: float | None, hi: float | None, places: int, suffix: str) -> str:
    if lo is None or hi is None:
        return "-"
    if math.isclose(lo, hi, abs_tol=10 ** (-(places + 1))):
        return f"{float(lo):.{places}f}{suffix}"
    return f"{float(lo):.{places}f}–{float(hi):.{places}f}{suffix}"


def _is_deep(group: Mapping[str, Any]) -> bool:
    depth = group.get("depth_in")
    dia = group.get("dia")
    if not depth or not dia:
        return False
    return (float(depth) / float(dia)) >= 3.0


def _sum_minutes(groups: Sequence[Mapping[str, Any]]) -> float:
    mins = [
        float(g.get("t_per_hole_min", 0.0)) * int(g.get("qty", 0))
        for g in groups
        if g.get("t_per_hole_min")
    ]
    return float(sum(mins))


def _holes_counts(groups: Sequence[Mapping[str, Any]]) -> tuple[int, int, int]:
    deep = sum(int(g.get("qty", 0)) for g in groups if _is_deep(g))
    std = sum(int(g.get("qty", 0)) for g in groups if not _is_deep(g))
    return deep, std, deep + std


def _dia_range(groups: Sequence[Mapping[str, Any]]) -> str:
    return _en_range((g.get("dia") for g in groups), 3)


def _depth_range(groups: Sequence[Mapping[str, Any]]) -> str:
    return _en_range((g.get("depth_in") for g in groups), 2)


def _rpm_range(groups: Sequence[Mapping[str, Any]], deep: bool | None = None) -> str:
    rpms: list[float | None] = []
    for group in groups:
        if deep is None or _is_deep(group) == deep:
            rpms.append(_calc_rpm(group.get("sfm"), group.get("dia")))
    return _en_range(rpms, 0)


def _ipm_range(groups: Sequence[Mapping[str, Any]], deep: bool | None = None) -> str:
    ipms: list[float | None] = []
    for group in groups:
        if deep is None or _is_deep(group) == deep:
            rpm = _calc_rpm(group.get("sfm"), group.get("dia"))
            ipm = _calc_ipm(rpm, group.get("ipr"))
            ipms.append(ipm)
    return _en_range(ipms, 1)


def render_drilling_section(
    material: str,
    block_thickness: Number,
    drill_groups: Sequence[Mapping[str, Any]],
    overheads: Mapping[str, Number],
) -> str:
    counts_by_diam = _aggregate_counts_by_diameter(drill_groups)
    per_diam_depth = _per_diameter_depths(drill_groups)
    deep_ct, std_ct = _classify_deep_std(per_diam_depth, counts_by_diam)
    total_ct = deep_ct + std_ct
    if total_ct == 0:
        deep_ct, std_ct, total_ct = _holes_counts(drill_groups)
    deep_groups = [g for g in drill_groups if _is_deep(g)]
    std_groups = [g for g in drill_groups if not _is_deep(g)]

    diameters = [dia for dia, qty in counts_by_diam.items() if qty > 0]
    depths = [
        per_diam_depth.get(dia)
        for dia in diameters
        if per_diam_depth.get(dia) is not None
    ]
    diam_min = min(diameters) if diameters else None
    diam_max = max(diameters) if diameters else None
    depth_min = min(depths) if depths else None
    depth_max = max(depths) if depths else None
    dia_range = _format_range(diam_min, diam_max, 3, '"')
    depth_range = _format_range(depth_min, depth_max, 2, " in")

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – DRILLING")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    ops_str = "Deep-Drill (L/D ≥ 3), Drill" if deep_ct else "Drill"
    lines.append(f"  Operations ........ {ops_str}")
    lines.append(f"  Holes ............. {deep_ct} deep + {std_ct} std  = {total_ct}")
    lines.append(f"  Diameter range .... {dia_range}")
    lines.append(f"  Depth per hole .... {depth_range}")
    lines.append("")
    lines.append("Feeds & Speeds (used)")
    lines.append(
        "  SFM ............... "
        f"{_en_range((g.get('sfm') for g in deep_groups), 0)} (deep)   | "
        f"{_en_range((g.get('sfm') for g in std_groups), 0)} (std)"
    )
    lines.append(
        "  IPR ............... "
        f"{_en_range((g.get('ipr') for g in deep_groups), 4)} (deep) | "
        f"{_en_range((g.get('ipr') for g in std_groups), 4)} (std)"
    )
    lines.append(
        "  RPM ............... "
        f"{_rpm_range(drill_groups, True)} (deep)      | "
        f"{_rpm_range(drill_groups, False)} (std)"
    )
    lines.append(
        "  IPM ............... "
        f"{_ipm_range(drill_groups, True)} (deep)       | "
        f"{_ipm_range(drill_groups, False)} (std)"
    )
    lines.append("")
    lines.append("Overheads")
    lines.append(
        f"  Index per hole .... {_fmt(overheads['index_per_hole_min'], 2)} min"
    )
    lines.append(
        f"  Peck per hole ..... {_fmt(overheads['peck_per_hole_min'], 2)} min"
    )
    lines.append(
        "  Toolchange ........ "
        f"{_fmt(overheads['toolchange_deep_min'], 2)} min (deep) | "
        f"{_fmt(overheads['toolchange_std_min'], 2)} min (std)"
    )
    lines.append("")
    lines.append("TIME PER HOLE – DRILL GROUPS")
    lines.append("------------------------------------------------------------------")

    for group in drill_groups:
        rpm = _calc_rpm(group.get("sfm"), group.get("dia"))
        ipm = _calc_ipm(rpm, group.get("ipr"))
        _ = ipm  # maintained for parity with the reference implementation
        tph = group.get("t_per_hole_min")
        group_minutes = (float(tph) * int(group.get("qty", 0))) if tph else None
        dia_str = _fmt3(group["dia"])
        depth_str = _fmt3(group.get("depth_in", 0.0))
        sfm_str = f"{int(group['sfm'])}" if group.get("sfm") else "-"
        ipr_val = group.get("ipr")
        ipr_str = f"{float(ipr_val):.4f}" if ipr_val is not None else "-"
        tph_str = f"{float(tph):.2f} min" if tph else "—"
        if tph and group_minutes is not None:
            group_str = (
                f"{group['qty']}×{float(tph):.2f} = {group_minutes:.2f} min"
            )
        else:
            group_str = f"{group['qty']}×— = —"
        lines.append(
            f"Dia {dia_str}\" × {group['qty']}  | depth {depth_str}\" | "
            f"{sfm_str} sfm | {ipr_str} ipr | t/hole {tph_str} | group {group_str}"
        )

    deep_tc = float(overheads["toolchange_deep_min"]) if deep_ct else 0.0
    std_tc = float(overheads["toolchange_std_min"]) if std_ct else 0.0
    lines.append("")
    lines.append(
        "Toolchange adders: Deep-Drill "
        f"{_fmt(deep_tc, 2)} min + Drill {_fmt(std_tc, 2)} min = {_fmt(deep_tc + std_tc, 2)} min"
    )
    lines.append("------------------------------------------------------------------")

    per_hole_sum_min = _sum_minutes(drill_groups)
    total_with_tc = per_hole_sum_min + deep_tc + std_tc
    lines.append(
        f"Subtotal (per-hole × qty) . {_fmt(per_hole_sum_min, 2)} min  "
        f"({_fmt(per_hole_sum_min / 60, 2)} hr)"
    )
    lines.append(
        "TOTAL DRILLING (with toolchange) . "
        f"{_fmt(total_with_tc, 2)} min  ({_fmt(total_with_tc / 60, 2)} hr)"
    )
    lines.append("")
    return "\n".join(lines)


def render_tapping_section(
    material: str,
    tap_groups: Sequence[Mapping[str, Any]],
) -> str:
    total = sum(int(group.get("qty", 0)) for group in tap_groups)
    front = sum(int(group.get("qty", 0)) for group in tap_groups if group.get("side") == "FRONT")
    back = sum(int(group.get("qty", 0)) for group in tap_groups if group.get("side") == "BACK")

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – TAPPING")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    lines.append("  Ops ............... Tapping (front + back), pre-drill counted in drilling")
    lines.append(f"  Taps .............. {total} total  → {front} front, {back} back")
    threads = ", ".join(sorted({str(group["thread"]) for group in tap_groups}))
    lines.append(f"  Threads ........... {threads}")
    depth_vals: list[float | None] = []
    for group in tap_groups:
        depth = group.get("depth_in")
        depth_vals.append(float(depth) if depth is not None else None)
    lines.append(
        f"  Depth range ....... THRU, {_en_range((v for v in depth_vals if v), 2)}"
    )
    lines.append(f"  Flip required ..... {'Yes' if back and front else 'No'}")
    lines.append("")
    lines.append("Feeds & Speeds (engine uses your CSV)")
    pitch_rows = []
    for group in sorted(tap_groups, key=lambda g: str(g["thread"])):
        pitch = group.get("pitch_ipr")
        pitch_rows.append(
            f"{group['thread'].split('-')[-1]} TPI→{float(pitch):.5f}" if pitch else f"{group['thread']}→-"
        )
    lines.append("  Pitch (IPR) ....... " + " | ".join(pitch_rows))
    lines.append("  RPM ............... = (SFM × 3.82) / Tap Ø")
    lines.append("  IPM ............... = RPM × Pitch")
    lines.append("")
    lines.append("TIME PER HOLE – TAP GROUPS")
    lines.append("------------------------------------------------------------------")
    for group in tap_groups:
        pitch = group.get("pitch_ipr")
        pitch_str = f"{float(pitch):.4f} ipr" if pitch else "-"
        depth = group.get("depth_in")
        depth_str = "THRU" if depth is None else f"{_fmt(depth, 2)}\""
        tph = group.get("t_per_hole_min")
        tph_str = f"{float(tph):.2f} min" if tph else "—"
        group_minutes = (
            f"{group['qty']}×{float(tph):.2f} = {float(tph) * int(group.get('qty', 0)):.2f} min"
            if tph
            else "—"
        )
        pilot = group.get("pilot_dia")
        pilot_str = f"{float(pilot):.4f}\"" if pilot else "-"
        lines.append(
            f"{group['thread']} × {int(group.get('qty', 0)):>2}  ({group.get('side', '-')})   | "
            f"pilot {pilot_str} | depth {depth_str}  | pitch {pitch_str} | "
            f"t/hole {tph_str} | group {group_minutes}"
        )
    lines.append("")
    lines.append("Toolchange adders: Tap tool(s) — min (engine) ")
    lines.append("------------------------------------------------------------------")
    return "\n".join(lines)


def render_counterbore_section(
    material: str,
    cbore_groups: Sequence[Mapping[str, Any]],
) -> str:
    total = sum(int(group.get("qty", 0)) for group in cbore_groups)
    front = sum(
        int(group.get("qty", 0)) for group in cbore_groups if group.get("side") == "FRONT"
    )
    back = sum(
        int(group.get("qty", 0)) for group in cbore_groups if group.get("side") == "BACK"
    )

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – COUNTERBORE")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    lines.append("  Ops ............... Counterbore (front + back)")
    lines.append(
        f"  Counterbores ...... {total} total  → {front} front, {back} back"
    )
    dia_list = sorted({round(float(group["dia"]), 4) for group in cbore_groups})
    lines.append(
        "  Diameters ......... "
        + ", ".join(f"{dia:.4f}\"" for dia in dia_list)
    )
    depth_vals = [float(group["depth_in"]) for group in cbore_groups if group.get("depth_in") is not None]
    depth_range = _en_range(depth_vals, 2) if depth_vals else "—"
    lines.append(f"  Depth range ....... {depth_range}")
    if back and front:
        flip_required = "Yes"
    elif back or front:
        flip_required = "Yes"
    else:
        flip_required = "No"
    lines.append(f"  Flip required ..... {flip_required}")
    lines.append("")
    lines.append("Feeds & Speeds (engine uses your CSV)")
    lines.append("  RPM ............... = (SFM × 3.82) / C’bore Ø")
    lines.append("  IPM ............... = RPM × IPR (per tool)")
    lines.append("")
    lines.append("TIME PER HOLE – C’BORE GROUPS")
    lines.append("------------------------------------------------------------------")

    for group in cbore_groups:
        depth = group.get("depth_in")
        depth_str = f"{_fmt(depth, 2)}\"" if depth is not None else "—"
        tph = group.get("t_per_hole_min")
        tph_str = f"{float(tph):.2f} min" if tph else "—"
        group_minutes = (
            f"{group['qty']}×{float(tph):.2f} = {float(tph) * int(group.get('qty', 0)):.2f} min"
            if tph
            else "—"
        )
        lines.append(
            f"Ø{float(group['dia']):.4f}\" × {int(group.get('qty', 0)):>2} ({group.get('side', '-')})  | "
            f"depth {depth_str}   | t/hole {tph_str} | group {group_minutes}"
        )
    lines.append("")
    lines.append("Toolchange adders: C’bore tool(s) — min (engine)")
    lines.append("------------------------------------------------------------------")
    return "\n".join(lines)
