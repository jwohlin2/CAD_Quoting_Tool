"""Rendering helpers for drilling, tapping, and counterbore reports.

This module contains a pure-python rendering layer that turns normalized
operation groups (as generated by the pricing engine) into the formatted text
report shared by the quoting UI.
"""
from __future__ import annotations

from collections.abc import Iterable, Mapping, MutableMapping, Sequence
import math
from typing import Any

from cad_quoter.pricing.feed_math import approach_allowance_for_drill


_DRILL_TIME_CONTEXT: dict[str, float] = {}

Number = float | int


__all__ = [
    "render_drilling_section",
    "render_tapping_section",
    "render_counterbore_section",
]


def _fmt(value: Number, places: int = 2) -> str:
    return f"{float(value):.{places}f}"


def _fmt3(value: Number) -> str:
    return _fmt(value, 3)


def _en_range(values: Iterable[Number | None], places: int = 2) -> str:
    vals = [float(v) for v in values if v is not None]
    if not vals:
        return "-"
    lo = min(vals)
    hi = max(vals)
    if math.isclose(lo, hi, abs_tol=1e-9):
        return _fmt(lo, places)
    return f"{_fmt(lo, places)}–{_fmt(hi, places)}"


def _calc_rpm(sfm: Number | None, dia_in: Number | None) -> float | None:
    if not sfm or not dia_in:
        return None
    return (float(sfm) * 3.82) / float(dia_in)


def _calc_ipm(rpm: float | None, ipr: Number | None) -> float | None:
    if rpm is None or ipr is None:
        return None
    return rpm * float(ipr)


def _drill_time_model(depth_in: float, rpm: float, ipr: float) -> float:
    """Approximate the per-hole drilling time in minutes.

    The quoting engine exposes the adjusted drilling bins without detailed
    timing metrics for each diameter.  This helper mirrors the estimator's
    lightweight model so the rendered report reflects the same assumptions.
    """

    depth = max(float(depth_in), 0.0)
    feed = max(float(ipr), 0.0)
    spindle = max(float(rpm), 0.0)
    ipm = max(spindle * feed, 1e-6)

    # Approximate the axial distance travelled by the drill. Include a
    # simplified allowance for the drill point as well as a minor breakthrough
    # factor so thin parts still accrue reasonable time.
    dia_equiv = float(_DRILL_TIME_CONTEXT.get("dia", 0.0))
    if dia_equiv <= 0.0:
        ld_hint = _DRILL_TIME_CONTEXT.get("ld", 0.0)
        if ld_hint > 0.0:
            dia_equiv = depth / ld_hint
        if dia_equiv <= 0.0:
            dia_equiv = max(depth / 3.0, 1e-3)
    point_allowance = approach_allowance_for_drill(dia_equiv, 118.0)
    axial_depth = depth + point_allowance + 0.1 * dia_equiv

    cut_min = axial_depth / ipm

    # Light peck penalty keeps deep holes from looking artificially fast.
    ld_ratio = depth / dia_equiv if dia_equiv > 0 else 0.0
    peck_penalty = 0.07 if ld_ratio >= 3.0 else 0.02
    peck_min = peck_penalty * depth

    # A simple approach / retract time assuming a mid-range VMC rapid rate.
    rapid_ipm = 200.0
    approach = 0.25
    rapid_min = (2.0 * approach) / rapid_ipm

    return cut_min + peck_min + rapid_min


def _aggregate_counts_by_diameter(
    groups: Sequence[Mapping[str, Any]]
) -> dict[float, int]:
    counts: dict[float, int] = {}
    for group in groups:
        dia = group.get("dia")
        qty = group.get("qty")
        if dia is None or qty is None:
            continue
        try:
            dia_val = float(dia)
            qty_int = int(qty)
        except (TypeError, ValueError):
            continue
        if dia_val <= 0 or qty_int <= 0:
            continue
        counts[dia_val] = counts.get(dia_val, 0) + qty_int
    return counts


def _coerce_counts_mapping(
    payload: Mapping[Any, Any]
) -> dict[float, int]:
    counts: dict[float, int] = {}
    for raw_key, raw_val in payload.items():
        try:
            dia = float(raw_key)
            qty = int(raw_val)
        except (TypeError, ValueError):
            continue
        if dia <= 0 or qty <= 0:
            continue
        counts[dia] = qty
    return counts


def _extract_counts_override(
    groups: Sequence[Mapping[str, Any]]
) -> dict[float, int] | None:
    combined: dict[float, int] = {}
    found = False
    for group in groups:
        if not isinstance(group, Mapping):
            continue
        candidates: list[Mapping[Any, Any]] = []
        direct = group.get("counts_by_diam")
        if isinstance(direct, Mapping):
            candidates.append(direct)
        meta = group.get("meta")
        if isinstance(meta, Mapping):
            meta_direct = meta.get("counts_by_diam")
            if isinstance(meta_direct, Mapping):
                candidates.append(meta_direct)
        for candidate in candidates:
            coerced = _coerce_counts_mapping(candidate)
            if coerced:
                combined.update(coerced)
                found = True
    return combined if found else None


def _per_diameter_metrics(
    groups: Sequence[Mapping[str, Any]]
) -> dict[float, dict[str, float]]:
    metrics: dict[float, dict[str, float]] = {}
    aggregates: dict[float, dict[str, float]] = {}
    for group in groups:
        dia = group.get("dia")
        qty = group.get("qty")
        if dia is None or qty is None:
            continue
        try:
            dia_val = float(dia)
            qty_int = int(qty)
        except (TypeError, ValueError):
            continue
        if dia_val <= 0 or qty_int <= 0:
            continue
        bucket = aggregates.setdefault(
            dia_val,
            {
                "qty": 0.0,
                "t_total": 0.0,
                "t_qty": 0.0,
                "sfm_total": 0.0,
                "sfm_count": 0.0,
                "ipr_total": 0.0,
                "ipr_count": 0.0,
            },
        )
        bucket["qty"] += float(qty_int)
        tph = group.get("t_per_hole_min")
        if tph is None:
            tph = group.get("minutes_per_hole")
        try:
            tph_val = float(tph) if tph is not None else None
        except (TypeError, ValueError):
            tph_val = None
        if tph_val is not None and math.isfinite(tph_val) and tph_val > 0.0:
            bucket["t_total"] += tph_val * float(qty_int)
            bucket["t_qty"] += float(qty_int)
        sfm = group.get("sfm")
        try:
            sfm_val = float(sfm) if sfm is not None else None
        except (TypeError, ValueError):
            sfm_val = None
        if sfm_val is not None and math.isfinite(sfm_val) and sfm_val > 0.0:
            bucket["sfm_total"] += sfm_val
            bucket["sfm_count"] += 1.0
        ipr = group.get("ipr")
        try:
            ipr_val = float(ipr) if ipr is not None else None
        except (TypeError, ValueError):
            ipr_val = None
        if ipr_val is not None and math.isfinite(ipr_val) and ipr_val > 0.0:
            bucket["ipr_total"] += ipr_val
            bucket["ipr_count"] += 1.0

    for dia, bucket in aggregates.items():
        out: dict[str, float] = {}
        if bucket["t_qty"] > 0.0:
            out["t_per"] = bucket["t_total"] / bucket["t_qty"]
        if bucket["sfm_count"] > 0.0:
            out["sfm"] = bucket["sfm_total"] / bucket["sfm_count"]
        if bucket["ipr_count"] > 0.0:
            out["ipr"] = bucket["ipr_total"] / bucket["ipr_count"]
        metrics[dia] = out
    return metrics


def _per_diameter_depths(groups: Sequence[Mapping[str, Any]]) -> dict[float, float]:
    totals: dict[float, tuple[float, int]] = {}
    for group in groups:
        dia = group.get("dia")
        depth = group.get("depth_in")
        qty = group.get("qty")
        if dia is None or depth is None or qty is None:
            continue
        try:
            dia_val = float(dia)
            depth_val = float(depth)
            qty_int = int(qty)
        except (TypeError, ValueError):
            continue
        if dia_val <= 0 or qty_int <= 0:
            continue
        acc_depth, acc_qty = totals.get(dia_val, (0.0, 0))
        totals[dia_val] = (acc_depth + depth_val * qty_int, acc_qty + qty_int)

    averages: dict[float, float] = {}
    for dia, (depth_sum, qty_sum) in totals.items():
        if qty_sum > 0:
            averages[dia] = depth_sum / qty_sum
    return averages


def _classify_deep_std(
    per_diam_depth: Mapping[float, float], counts: Mapping[float, int]
) -> tuple[int, int]:
    deep = std = 0
    for diameter, qty in counts.items():
        qty_int = int(qty)
        if qty_int <= 0:
            continue
        depth = per_diam_depth.get(diameter)
        if depth is None:
            continue
        if diameter > 0 and (depth / diameter) >= 3.0:
            deep += qty_int
        else:
            std += qty_int
    return deep, std


def _format_range(lo: float | None, hi: float | None, places: int, suffix: str) -> str:
    if lo is None or hi is None:
        return "-"
    if math.isclose(lo, hi, abs_tol=10 ** (-(places + 1))):
        return f"{float(lo):.{places}f}{suffix}"
    return f"{float(lo):.{places}f}–{float(hi):.{places}f}{suffix}"


def _is_deep(group: Mapping[str, Any]) -> bool:
    depth = group.get("depth_in")
    dia = group.get("dia")
    if not depth or not dia:
        return False
    return (float(depth) / float(dia)) >= 3.0


def _sum_minutes(groups: Sequence[Mapping[str, Any]]) -> float:
    mins = [
        float(g.get("t_per_hole_min", 0.0)) * int(g.get("qty", 0))
        for g in groups
        if g.get("t_per_hole_min")
    ]
    return float(sum(mins))


def _holes_counts(groups: Sequence[Mapping[str, Any]]) -> tuple[int, int, int]:
    deep = sum(int(g.get("qty", 0)) for g in groups if _is_deep(g))
    std = sum(int(g.get("qty", 0)) for g in groups if not _is_deep(g))
    return deep, std, deep + std


def _dia_range(groups: Sequence[Mapping[str, Any]]) -> str:
    return _en_range((g.get("dia") for g in groups), 3)


def _depth_range(groups: Sequence[Mapping[str, Any]]) -> str:
    return _en_range((g.get("depth_in") for g in groups), 2)


def _rpm_range(groups: Sequence[Mapping[str, Any]], deep: bool | None = None) -> str:
    rpms: list[float | None] = []
    for group in groups:
        if deep is None or _is_deep(group) == deep:
            rpms.append(_calc_rpm(group.get("sfm"), group.get("dia")))
    return _en_range(rpms, 0)


def _ipm_range(groups: Sequence[Mapping[str, Any]], deep: bool | None = None) -> str:
    ipms: list[float | None] = []
    for group in groups:
        if deep is None or _is_deep(group) == deep:
            rpm = _calc_rpm(group.get("sfm"), group.get("dia"))
            ipm = _calc_ipm(rpm, group.get("ipr"))
            ipms.append(ipm)
    return _en_range(ipms, 1)


def render_drilling_section(
    material: str,
    block_thickness: Number,
    drill_groups: Sequence[Mapping[str, Any]],
    overheads: Mapping[str, Number],
    breakdown_mutable: MutableMapping[str, Any] | None = None,
) -> str:
    counts_override = _extract_counts_override(drill_groups)
    counts_by_diam = counts_override or _aggregate_counts_by_diameter(drill_groups)
    per_diam_depth = _per_diameter_depths(drill_groups)
    deep_ct, std_ct = _classify_deep_std(per_diam_depth, counts_by_diam)
    total_ct = deep_ct + std_ct
    if total_ct == 0:
        deep_ct, std_ct, total_ct = _holes_counts(drill_groups)
    deep_groups = [g for g in drill_groups if _is_deep(g)]
    std_groups = [g for g in drill_groups if not _is_deep(g)]

    diameters = [dia for dia, qty in counts_by_diam.items() if qty > 0]
    depths = [
        per_diam_depth.get(dia)
        for dia in diameters
        if per_diam_depth.get(dia) is not None
    ]
    diam_min = min(diameters) if diameters else None
    diam_max = max(diameters) if diameters else None
    depth_min = min(depths) if depths else None
    depth_max = max(depths) if depths else None
    dia_range = _format_range(diam_min, diam_max, 3, '"')
    depth_range = _format_range(depth_min, depth_max, 2, " in")

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – DRILLING")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    ops_str = "Deep-Drill (L/D ≥ 3), Drill" if deep_ct else "Drill"
    lines.append(f"  Operations ........ {ops_str}")
    lines.append(f"  Holes ............. {deep_ct} deep + {std_ct} std  = {total_ct}")
    lines.append(f"  Diameter range .... {dia_range}")
    lines.append(f"  Depth per hole .... {depth_range}")
    lines.append("")
    lines.append("Feeds & Speeds (used)")
    lines.append(
        "  SFM ............... "
        f"{_en_range((g.get('sfm') for g in deep_groups), 0)} (deep)   | "
        f"{_en_range((g.get('sfm') for g in std_groups), 0)} (std)"
    )
    lines.append(
        "  IPR ............... "
        f"{_en_range((g.get('ipr') for g in deep_groups), 4)} (deep) | "
        f"{_en_range((g.get('ipr') for g in std_groups), 4)} (std)"
    )
    lines.append(
        "  RPM ............... "
        f"{_rpm_range(drill_groups, True)} (deep)      | "
        f"{_rpm_range(drill_groups, False)} (std)"
    )
    lines.append(
        "  IPM ............... "
        f"{_ipm_range(drill_groups, True)} (deep)       | "
        f"{_ipm_range(drill_groups, False)} (std)"
    )
    lines.append("")
    lines.append("Overheads")
    lines.append(
        f"  Index per hole .... {_fmt(overheads['index_per_hole_min'], 2)} min"
    )
    lines.append(
        f"  Peck per hole ..... {_fmt(overheads['peck_per_hole_min'], 2)} min"
    )
    lines.append(
        "  Toolchange ........ "
        f"{_fmt(overheads['toolchange_deep_min'], 2)} min (deep) | "
        f"{_fmt(overheads['toolchange_std_min'], 2)} min (std)"
    )
    lines.append("")
    lines.append("TIME PER HOLE – DRILL GROUPS")
    lines.append("------------------------------------------------------------------")

    per_hole_sum_min = 0.0
    drill_group_lines: list[str] = []
    for d in sorted(counts_by_diam.keys()):
        qty = int(counts_by_diam[d])
        if qty <= 0:
            continue
        try:
            depth = float(per_diam_depth.get(d, block_thickness))
        except (TypeError, ValueError):
            depth = 2.0
        ld = (depth / d) if d > 0 else 0.0
        sfm, ipr = ((39, 0.0020) if ld >= 3.0 else (80, 0.0060))
        rpm = (sfm * 3.82) / max(d, 0.001)
        ipm = rpm * ipr
        _DRILL_TIME_CONTEXT["dia"] = float(d)
        _DRILL_TIME_CONTEXT["ld"] = float(ld)
        _DRILL_TIME_CONTEXT["sfm"] = float(sfm)
        t_hole = _drill_time_model(depth, rpm, ipr)
        group_minutes = qty * t_hole
        per_hole_sum_min += group_minutes
        drill_group_lines.append(
            f'Dia {d:.3f}" × {qty}  | depth {depth:.3f}" | {sfm} sfm | '
            f'{ipr:.4f} ipr | t/hole {t_hole:.2f} min | '
            f'group {qty}×{t_hole:.2f} = {group_minutes:.2f} min'
        )

    _DRILL_TIME_CONTEXT.clear()

    if not drill_group_lines:
        for group in drill_groups:
            rpm = _calc_rpm(group.get("sfm"), group.get("dia"))
            ipm = _calc_ipm(rpm, group.get("ipr"))
            _ = ipm
            tph = group.get("t_per_hole_min")
            if tph:
                per_hole_sum_min += float(tph) * int(group.get("qty", 0))
            dia = float(group.get("dia") or 0.0)
            depth = float(group.get("depth_in") or 0.0)
            sfm_val = group.get("sfm")
            ipr_val = group.get("ipr")
            tph_str = f"{float(tph):.2f} min" if tph else "—"
            group_minutes = (
                f"{group['qty']}×{float(tph):.2f} = {float(tph) * int(group.get('qty', 0)):.2f} min"
                if tph
                else f"{group['qty']}×— = —"
            )
            drill_group_lines.append(
                f"Dia {_fmt3(dia)}\" × {group['qty']}  | depth {_fmt3(depth)}\" | "
                f"{int(float(sfm_val)) if sfm_val else '-'} sfm | "
                f"{f'{float(ipr_val):.4f}' if ipr_val is not None else '-'} ipr | "
                f"t/hole {tph_str} | group {group_minutes}"
            )

    lines.extend(drill_group_lines)

    deep_tc = float(overheads["toolchange_deep_min"]) if deep_ct else 0.0
    std_tc = float(overheads["toolchange_std_min"]) if std_ct else 0.0
    lines.append("")
    lines.append(
        "Toolchange adders: Deep-Drill "
        f"{_fmt(deep_tc, 2)} min + Drill {_fmt(std_tc, 2)} min = {_fmt(deep_tc + std_tc, 2)} min"
    )
    lines.append("------------------------------------------------------------------")

    total_with_tc = per_hole_sum_min + deep_tc + std_tc
    lines.append(
        f"Subtotal (per-hole × qty) . {_fmt(per_hole_sum_min, 2)} min  "
        f"({_fmt(per_hole_sum_min / 60, 2)} hr)"
    )
    lines.append(
        "TOTAL DRILLING (with toolchange) . "
        f"{_fmt(total_with_tc, 2)} min  ({_fmt(total_with_tc / 60, 2)} hr)"
    )
    lines.append("")

    if isinstance(breakdown_mutable, MutableMapping):
        try:
            extra_bucket_ops = breakdown_mutable.setdefault("extra_bucket_ops", {})
            if isinstance(extra_bucket_ops, MutableMapping):
                total_qty = int(sum(int(v) for v in counts_by_diam.values()))
                extra_bucket_ops.setdefault("drill", []).append(
                    {"name": "Drill", "qty": total_qty, "side": None}
                )
        except Exception:  # pragma: no cover - defensive
            pass

    return "\n".join(lines)


def render_tapping_section(
    material: str,
    tap_groups: Sequence[Mapping[str, Any]],
) -> str:
    total = sum(int(group.get("qty", 0)) for group in tap_groups)
    front = sum(int(group.get("qty", 0)) for group in tap_groups if group.get("side") == "FRONT")
    back = sum(int(group.get("qty", 0)) for group in tap_groups if group.get("side") == "BACK")

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – TAPPING")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    lines.append("  Ops ............... Tapping (front + back), pre-drill counted in drilling")
    lines.append(f"  Taps .............. {total} total  → {front} front, {back} back")
    threads = ", ".join(sorted({str(group["thread"]) for group in tap_groups}))
    lines.append(f"  Threads ........... {threads}")
    depth_vals: list[float | None] = []
    for group in tap_groups:
        depth = group.get("depth_in")
        depth_vals.append(float(depth) if depth is not None else None)
    lines.append(
        f"  Depth range ....... THRU, {_en_range((v for v in depth_vals if v), 2)}"
    )
    lines.append(f"  Flip required ..... {'Yes' if back and front else 'No'}")
    lines.append("")
    lines.append("Feeds & Speeds (engine uses your CSV)")
    pitch_rows = []
    for group in sorted(tap_groups, key=lambda g: str(g["thread"])):
        pitch = group.get("pitch_ipr")
        pitch_rows.append(
            f"{group['thread'].split('-')[-1]} TPI→{float(pitch):.5f}" if pitch else f"{group['thread']}→-"
        )
    lines.append("  Pitch (IPR) ....... " + " | ".join(pitch_rows))
    lines.append("  RPM ............... = (SFM × 3.82) / Tap Ø")
    lines.append("  IPM ............... = RPM × Pitch")
    lines.append("")
    lines.append("TIME PER HOLE – TAP GROUPS")
    lines.append("------------------------------------------------------------------")
    for group in tap_groups:
        pitch = group.get("pitch_ipr")
        pitch_str = f"{float(pitch):.4f} ipr" if pitch else "-"
        depth = group.get("depth_in")
        depth_str = "THRU" if depth is None else f"{_fmt(depth, 2)}\""
        tph = group.get("t_per_hole_min")
        tph_str = f"{float(tph):.2f} min" if tph else "—"
        group_minutes = (
            f"{group['qty']}×{float(tph):.2f} = {float(tph) * int(group.get('qty', 0)):.2f} min"
            if tph
            else "—"
        )
        pilot = group.get("pilot_dia")
        pilot_str = f"{float(pilot):.4f}\"" if pilot else "-"
        lines.append(
            f"{group['thread']} × {int(group.get('qty', 0)):>2}  ({group.get('side', '-')})   | "
            f"pilot {pilot_str} | depth {depth_str}  | pitch {pitch_str} | "
            f"t/hole {tph_str} | group {group_minutes}"
        )
    lines.append("")
    lines.append("Toolchange adders: Tap tool(s) — min (engine) ")
    lines.append("------------------------------------------------------------------")
    return "\n".join(lines)


def render_counterbore_section(
    material: str,
    cbore_groups: Sequence[Mapping[str, Any]],
) -> str:
    total = sum(int(group.get("qty", 0)) for group in cbore_groups)
    front = sum(
        int(group.get("qty", 0)) for group in cbore_groups if group.get("side") == "FRONT"
    )
    back = sum(
        int(group.get("qty", 0)) for group in cbore_groups if group.get("side") == "BACK"
    )

    lines: list[str] = []
    lines.append("MATERIAL REMOVAL – COUNTERBORE")
    lines.append("================================================================")
    lines.append("Inputs")
    lines.append(f"  Material .......... {material}  [group -]")
    lines.append("  Ops ............... Counterbore (front + back)")
    lines.append(
        f"  Counterbores ...... {total} total  → {front} front, {back} back"
    )
    dia_list = sorted({round(float(group["dia"]), 4) for group in cbore_groups})
    lines.append(
        "  Diameters ......... "
        + ", ".join(f"{dia:.4f}\"" for dia in dia_list)
    )
    depth_vals = [float(group["depth_in"]) for group in cbore_groups if group.get("depth_in") is not None]
    depth_range = _en_range(depth_vals, 2) if depth_vals else "—"
    lines.append(f"  Depth range ....... {depth_range}")
    if back and front:
        flip_required = "Yes"
    elif back or front:
        flip_required = "Yes"
    else:
        flip_required = "No"
    lines.append(f"  Flip required ..... {flip_required}")
    lines.append("")
    lines.append("Feeds & Speeds (engine uses your CSV)")
    lines.append("  RPM ............... = (SFM × 3.82) / C’bore Ø")
    lines.append("  IPM ............... = RPM × IPR (per tool)")
    lines.append("")
    lines.append("TIME PER HOLE – C’BORE GROUPS")
    lines.append("------------------------------------------------------------------")

    for group in cbore_groups:
        depth = group.get("depth_in")
        depth_str = f"{_fmt(depth, 2)}\"" if depth is not None else "—"
        tph = group.get("t_per_hole_min")
        tph_str = f"{float(tph):.2f} min" if tph else "—"
        group_minutes = (
            f"{group['qty']}×{float(tph):.2f} = {float(tph) * int(group.get('qty', 0)):.2f} min"
            if tph
            else "—"
        )
        lines.append(
            f"Ø{float(group['dia']):.4f}\" × {int(group.get('qty', 0)):>2} ({group.get('side', '-')})  | "
            f"depth {depth_str}   | t/hole {tph_str} | group {group_minutes}"
        )
    lines.append("")
    lines.append("Toolchange adders: C’bore tool(s) — min (engine)")
    lines.append("------------------------------------------------------------------")
    return "\n".join(lines)
